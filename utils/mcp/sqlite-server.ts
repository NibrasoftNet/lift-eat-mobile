import { useSQLiteContext } from 'expo-sqlite';
import { drizzle } from 'drizzle-orm/expo-sqlite';
import * as schema from '@/db/schema';
import { 
  mealIngredients,
  ingredientsStandard,
  meals,
  dailyPlan,
  dailyPlanMeals,
  plan,
  users,
  PlanOrmProps,
  DailyPlanOrmProps,
  MealOrmProps,
  scanHistory
} from '@/db/schema';
import { eq, and, like, inArray } from 'drizzle-orm';
import { 
  IaIngredientType,
  IaMealType,
  IaPlanType 
} from '@/utils/validation/ia/ia.schemas';
import { GoalEnum } from '@/utils/enum/user-details.enum';
import { sql } from 'drizzle-orm';
import { logger } from '@/utils/services/common/logging.service';
import { LogCategory } from '@/utils/enum/logging.enum';
import { invalidateCache, DataType } from '@/utils/helpers/queryInvalidation';
import { QueryClient } from '@tanstack/react-query';
import { 
  MealTypeEnum, 
  CuisineTypeEnum, 
  MealUnitEnum 
} from '@/utils/enum/meal.enum';
import { 
  PlanGeneratedWithEnum,
  DayEnum
} from '@/utils/enum/general.enum';
import { WeightUnitEnum } from '@/utils/enum/user-details.enum';

// Import des handlers et interfaces
import { 
  handleCreatePlan, 
  handleCreateDailyPlans, 
  handleUpdatePlan, 
  handleDeletePlan,
  handleAddDailyPlan,
  handleGetPlansList,
  handleGetPlanDetails,
  handleGetMealQuantityInPlan,
  handleUpdateMealQuantityInPlan,
  handleSetCurrentPlan,
  handleGetCurrentPlan,
  handleCalculateMealNutrition,
  handleGetDailyPlanNutrition,
} from './handlers/plan-handlers';
import { 
  handleGetMealsList,
  handleGetMealDetails,
  handleCreateMeal,
  handleCreateNewMeal,
  handleAddMealToDailyPlan as handleAddMealToDailyPlanMealHandler,
  handleUpdateMeal,
  handleDeleteMeal
} from './handlers/meal-handlers';
import {
  handleAddIngredient,
  handleGetIngredientsList,
  handleUpdateIngredient,
  handleDeleteIngredient
} from './handlers/ingredient-handlers';
import { 
  handleUpdateUserPreferences, 
  handleGetUserDetails, 
  handleCreateUser, 
  handleValidateUserExists,
  handleGetDefaultUser,
  handleGenerateUserContext,
  handleUpdateUserNutritionPreferences
} from './handlers/user-handlers';
import {
  handleGetDailyProgressByDate,
  handleCreateDailyProgress,
  handleUpdateDailyProgress,
  handleGetMealProgressByDate,
  handleMarkMealAsConsumed,
  handleGetMealProgressByDailyProgress,
  handleGetDailyProgressByPlan
} from './handlers/progress-handlers';

import {
  handleGetUserContext,
  handleGetUserPreferences,
  handleGetUserFavoriteMeals,
  handleGetUserActivePlans,
  handleGetUserActivityHistory,
  handleSaveNutritionAdvice,
  handleUpdateAdviceFeedback,
  handleGetNutritionAdvice,
} from './handlers/ia-handlers';

import { handleRemoveMealFromDailyPlan } from './handlers/plan-handlers-extension';

import {
  handleSaveIngredientSuggestion,
  handleGetIngredientSuggestions,
  handleUpdateIngredientSuggestion,
  handleDeleteIngredientSuggestion
} from './handlers/ingredient-suggestion-handlers';

import {
  handleCalculateNormalizedNutrition,
  handleGetMealWeight,
  handleGetMacroBreakdown
} from './handlers/nutrition-handlers';

import { handleAddScanHistory, handleGetScanHistory, handleClearScanHistory } from './handlers/scan-history-handlers';

// Imports des interfaces
import { CreateNewMealResult } from './interfaces/meal-interfaces';
import { 
  CreatePlanParams, 
  CreateDailyPlansParams, 
  PlanResult, 
  DailyPlansResult, 
  UpdatePlanParams, 
  DeletePlanParams, 
  DeletePlanResult, 
  BasicResult,
  AddDailyPlanParams,
  AddDailyPlanResult,
  GetMealQuantityInPlanParams,
  GetMealQuantityInPlanResult,
  UpdateMealQuantityInPlanParams,
  UpdateMealQuantityInPlanResult,
  SetCurrentPlanParams,
  SetCurrentPlanResult,
  GetCurrentPlanParams,
  GetCurrentPlanResult,
  GetDailyPlanNutritionParams,
  GetDailyPlanNutritionResult
} from './interfaces/plan-interfaces';
import {
  GetMealsListParams,
  GetMealsListResult,
  GetMealDetailsParams,
  GetMealDetailsResult,
  CreateMealParams,
  CreateMealResult,
  AddMealToDailyPlanParams,
  AddMealToDailyPlanResult
} from './interfaces/meal-interfaces';
import { NutritionGoalSchemaFormData } from '@/utils/validation/plan/nutrition-goal.validation';
import {
  AddIngredientParams,
  AddIngredientResult,
  GetIngredientsListParams,
  GetIngredientsListResult,
  UpdateIngredientParams,
  UpdateIngredientResult,
  DeleteIngredientParams,
  DeleteIngredientResult
} from './interfaces/ingredient-interfaces';
import {
  UpdateUserPreferencesParams,
  UpdateUserPreferencesResult,
  GetUserDetailsParams,
  GetUserDetailsResult,
  CreateUserParams,
  CreateUserResult,
  ValidateUserExistsParams,
  ValidateUserExistsResult,
  GetDefaultUserParams,
  GetDefaultUserResult,
  GenerateUserContextParams,
  GenerateUserContextResult,
  UpdateUserNutritionPreferencesParams
} from './interfaces/user-interfaces';
import {
  GetDailyProgressByDateParams,
  GetDailyProgressByDateResult,
  CreateDailyProgressParams,
  CreateDailyProgressResult,
  UpdateDailyProgressParams,
  UpdateDailyProgressResult,
  GetMealProgressByDateParams,
  GetMealProgressByDateResult,
  MarkMealAsConsumedParams,
  MarkMealAsConsumedResult,
  GetMealProgressByDailyProgressParams,
  GetMealProgressByDailyProgressResult,
  GetDailyProgressByPlanParams,
  GetDailyProgressByPlanResult
} from './interfaces/progress-interfaces';

import { 
  GetUserContextParams, 
  GetUserContextResult,
  GetUserPreferencesParams,
  GetUserPreferencesResult,
  GetUserFavoriteMealsParams,
  GetUserFavoriteMealsResult,
  GetUserActivePlansParams,
  GetUserActivePlansResult,
  GetUserActivityHistoryParams,
  GetUserActivityHistoryResult,
  SaveNutritionAdviceParams,
  SaveNutritionAdviceResult,
  UpdateAdviceFeedbackParams,
  UpdateAdviceFeedbackResult,
  GetNutritionAdviceParams,
  GetNutritionAdviceResult,
} from './interfaces/ia-interfaces';

import {
  SaveIngredientSuggestionParams,
  SaveIngredientSuggestionResult,
  GetIngredientSuggestionsParams,
  GetIngredientSuggestionsResult,
  UpdateIngredientSuggestionParams,
  UpdateIngredientSuggestionResult,
  DeleteIngredientSuggestionParams,
  DeleteIngredientSuggestionResult
} from './interfaces/ingredient-suggestion-interfaces';

import {
  CalculateNormalizedNutritionParams,
  NormalizedNutritionResult,
  GetMealWeightParams,
  GetMealWeightResult,
  GetMacroBreakdownParams,
  GetMacroBreakdownResult
} from './interfaces/nutrition-interfaces';

import { AddScanHistoryParams, GetScanHistoryParams } from './interfaces/scan-history-interfaces';

/**
 * SQLite MCP Server
 * 
 * This server provides access to user preferences and data from SQLite
 * to enable the Gemini model to provide more personalized responses.
 */
class SQLiteMCPServer {
  private static instance: SQLiteMCPServer;
  private db: any = null;

  private constructor() {}

  public static getInstance(): SQLiteMCPServer {
    if (!SQLiteMCPServer.instance) {
      SQLiteMCPServer.instance = new SQLiteMCPServer();
    }
    return SQLiteMCPServer.instance;
  }

  public initializeWithDb(sqliteDb: any) {
    try {
      this.db = drizzle(sqliteDb, { schema });
      logger.info(LogCategory.DATABASE, 'MCP Server database initialized successfully');
      // VÃ©rification rapide que la connexion fonctionne
      return true;
    } catch (error) {
      logger.error(LogCategory.DATABASE, `Failed to initialize MCP Server database: ${error instanceof Error ? error.message : String(error)}`);
      return false;
    }
  }

  /**
   * Get current user information
   */
  public async getCurrentUser(userId: number) {
    try {
      if (!this.db) throw new Error("Database not initialized");
      
      const userResults = await this.db.select().from(users).where(eq(users.id, userId));
      
      if (userResults.length === 0) {
        throw new Error(`User with ID ${userId} not found`);
      }
      
      return userResults[0];
    } catch (error) {
      console.error("Error fetching current user:", error);
      throw error;
    }
  }

  /**
   * Get user nutritional preferences
   */
  public async getUserNutritionalPreferences(userId: number) {
    try {
      if (!this.db) throw new Error("Database not initialized");
      
      const userResults = await this.db.select().from(users).where(eq(users.id, userId));
      
      if (userResults.length === 0) {
        throw new Error(`User with ID ${userId} not found`);
      }
      
      const user = userResults[0];
      
      // Extract nutritional preferences from user
      return {
        gender: user.gender,
        age: user.age,
        weight: user.weight,
        weightUnit: user.weightUnit,
        height: user.height,
        heightUnit: user.heightUnit,
        physicalActivity: user.physicalActivity,
        goalWeight: user.goalWeight,
        goal: user.goal,
        dietaryRestrictions: user.dietaryRestrictions || []
      };
    } catch (error) {
      console.error("Error fetching user nutritional preferences:", error);
      throw error;
    }
  }

  /**
   * Get user's favorite meals
   */
  public async getUserFavoriteMeals(userId: number, limit = 5) {
    try {
      if (!this.db) throw new Error("Database not initialized");
      
      // For now, just return the most recent meals added by the user
      // In the future, this could be based on ratings or frequency of consumption
      const userMeals = await this.db.select()
        .from(meals)
        .where(eq(meals.creatorId, userId))
        .orderBy(sql`${meals.createdAt} DESC`)
        .limit(limit);
      
      return userMeals;
    } catch (error) {
      console.error("Error fetching user favorite meals:", error);
      throw error;
    }
  }

  /**
   * Get user's active nutrition plans
   */
  public async getUserActivePlans(userId: number) {
    try {
      if (!this.db) throw new Error("Database not initialized");
      
      const userPlans = await this.db.select()
        .from(plan)
        .where(
          and(
            eq(plan.userId, userId),
            eq(plan.completed, false)
          )
        )
        .orderBy(sql`${plan.createdAt} DESC`);
      
      if (userPlans.length === 0) {
        return [];
      }
      
      // Get the plan that is marked as current
      const currentPlan = userPlans.find((p: PlanOrmProps) => p.current === true);
      
      // Add a property to indicate which plan is current
      return {
        plans: userPlans,
        currentPlan: currentPlan || null
      };
    } catch (error) {
      console.error("Error fetching user active plans:", error);
      throw error;
    }
  }

  /**
   * Generate user context for AI prompts
   * @param userId User ID
   * @returns User context string for AI prompts
   */
  public async generateUserContext(userId: number): Promise<string> {
    try {
      logger.info(LogCategory.DATABASE, `Generating user context for user ${userId}`);
      
      // Mesurer le temps d'accÃ¨s pour les logs de performance
      const startTime = performance.now();
      
      // Appel direct au handler pour gÃ©nÃ©rer le contexte
      const result = await handleGetUserContext(this.db, { userId });
      
      // Calculer le temps d'accÃ¨s pour les logs
      const accessTime = performance.now() - startTime;
      logger.debug(LogCategory.DATABASE, `Database access time for generating user context: ${accessTime.toFixed(2)}ms`);
      
      if (!result.success) {
        throw new Error(result.error);
      }
      
      // Retourner le contexte directement sans mise en cache
      if (result.context) {
        return result.context;
      }
      
      return "USER CONTEXT: Not available";
    } catch (error) {
      logger.error(LogCategory.DATABASE, `Error generating user context: ${error}`);
      return "USER CONTEXT: Not available";
    }
  }

  /**
   * RÃ©cupÃ¨re la liste des repas via le MCP server
   * @param params ParamÃ¨tres de la requÃªte, incluant userId et les filtres
   * @returns RÃ©sultat de l'opÃ©ration avec la liste des repas
   */
  public async getMealsListViaMCP(params: GetMealsListParams): Promise<GetMealsListResult> {
    try {
      if (!this.db) throw new Error("Database not initialized");
      
      logger.info(LogCategory.DATABASE, 'Getting meals list via MCP Server', { userId: params.userId, filters: params });
      
      const result = await handleGetMealsList(this.db, params);
      
      if (!result.success) {
        logger.error(LogCategory.DATABASE, `Failed to get meals list: ${result.error}`);
      } else {
        logger.info(LogCategory.DATABASE, `Successfully retrieved ${result.meals?.length} meals`);
      }
      
      return result;
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : String(error);
      logger.error(LogCategory.DATABASE, `Error getting meals list: ${errorMessage}`);
      return { success: false, error: errorMessage };
    }
  }

  /**
   * Ajoute un repas via le MCP server
   * @param meal DonnÃ©es du repas Ã  ajouter
   * @param creatorId ID de l'utilisateur crÃ©ateur
   * @returns RÃ©sultat de l'opÃ©ration avec l'ID du repas crÃ©Ã© ou une erreur
   */
  public async addMealViaMCP(
    meal: IaMealType, 
    creatorId: number
  ): Promise<CreateMealResult> {
    try {
      // VÃ©rifier que la base de donnÃ©es est initialisÃ©e
      if (!this.db) {
        throw new Error("Database not initialized");
      }
      
      // Transformer le type IaMealType en type attendu par handleCreateMeal
      const mealData: Omit<MealOrmProps, 'id'> = {
        ...meal,
        creatorId,
        isFavorite: false,
        createdAt: new Date().toISOString(),
        updatedAt: new Date().toISOString(),
        image: null,
      };
      
      // Extraire les ingrÃ©dients du repas
      const rawIngredients = meal.ingredients || [];
      
      // PrÃ©parer les ingrÃ©dients avec des IDs valides
      const processedIngredients = [];
      
      // Pour chaque ingrÃ©dient gÃ©nÃ©rÃ© par l'IA
      for (const ingredient of rawIngredients) {
        if (!ingredient.name) {
          logger.warn(LogCategory.DATABASE, `Skipping ingredient without name`);
          continue;
        }
        
        // Rechercher l'ingrÃ©dient par son nom dans la base de donnÃ©es
        const existingIngredient = await this.db
          .select()
          .from(ingredientsStandard)
          .where(eq(ingredientsStandard.name, ingredient.name))
          .limit(1);
        
        if (existingIngredient.length > 0) {
          // Si l'ingrÃ©dient existe dÃ©jÃ , utiliser son ID
          logger.info(LogCategory.DATABASE, `Found existing ingredient: ${ingredient.name} (ID: ${existingIngredient[0].id})`);
          processedIngredients.push({
            ...ingredient,
            id: existingIngredient[0].id
          });
        } else {
          // Si l'ingrÃ©dient n'existe pas, le crÃ©er
          logger.info(LogCategory.DATABASE, `Creating new ingredient: ${ingredient.name}`);
          
          const newIngredient = {
            name: ingredient.name,
            unit: ingredient.unit || "GRAMMES",
            calories: ingredient.calories || 0,
            carbs: ingredient.carbs || 0,
            protein: ingredient.protein || 0,
            fat: ingredient.fat || 0,
            createdAt: new Date().toISOString(),
            updatedAt: new Date().toISOString(),
            image: null
          };
          
          const [createdIngredient] = await this.db
            .insert(ingredientsStandard)
            .values(newIngredient)
            .returning({ id: ingredientsStandard.id });
          
          logger.info(LogCategory.DATABASE, `Created new ingredient: ${ingredient.name} (ID: ${createdIngredient.id})`);
          
          processedIngredients.push({
            ...ingredient,
            id: createdIngredient.id
          });
        }
      }
      
      // Appeler handleCreateMeal avec les donnÃ©es du repas et les ingrÃ©dients prÃ©parÃ©s
      logger.info(LogCategory.DATABASE, `Calling handleCreateMeal with ${processedIngredients.length} processed ingredients`);
      return handleCreateMeal(this.db, { 
        data: mealData, 
        userId: creatorId,
        ingredients: processedIngredients
      });
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : String(error);
      logger.error(LogCategory.DATABASE, `Error in addMealViaMCP: ${errorMessage}`);
      return { success: false, error: errorMessage };
    }
  }

  /**
   * Ajoute un plan nutritionnel via le MCP server
   * @param planData DonnÃ©es du plan Ã  ajouter
   * @param userId ID de l'utilisateur
   * @returns RÃ©sultat de l'opÃ©ration avec l'ID du plan crÃ©Ã© ou une erreur
   */
  public async addPlanViaMCP(
    planData: IaPlanType,
    userId: number
  ): Promise<PlanResult> {
    // CrÃ©er un objet NutritionGoalSchemaFormData Ã  partir des donnÃ©es disponibles
    // Comme IaPlanType ne contient pas les propriÃ©tÃ©s requises pour NutritionGoalSchemaFormData,
    // nous utilisons des valeurs par dÃ©faut tout en conservant l'objectif
    const formData: NutritionGoalSchemaFormData = {
      initialWeight: 70, // Valeur par dÃ©faut
      targetWeight: 65, // Valeur par dÃ©faut
      durationWeeks: 4, // Valeur par dÃ©faut
      goalUnit: planData.goal // Seule propriÃ©tÃ© que nous pouvons rÃ©cupÃ©rer du plan IA
    };
    
    return handleCreatePlan(this.db, { data: formData, userId });
  }



  /**
   * Ajoute un ingrÃ©dient standard via le MCP server
   * @param ingredientData DonnÃ©es de l'ingrÃ©dient Ã  ajouter
   * @param queryClient Client React Query pour l'invalidation du cache (optionnel)
   * @returns RÃ©sultat de l'opÃ©ration avec l'ID de l'ingrÃ©dient crÃ©Ã© ou une erreur
   */
  public async addIngredientViaMCP(
    ingredientData: IaIngredientType,
    queryClient?: QueryClient
  ): Promise<AddIngredientResult> {
    const startTime = logger.startPerformanceLog('addIngredientViaMCP');
    
    try {
      if (!this.db) throw new Error("Database not initialized");
      
      logger.info(LogCategory.DATABASE, `Adding ingredient "${ingredientData.name}" via MCP Server`);
      
      // Appeler le handler avec les paramÃ¨tres
      const result = await handleAddIngredient(this.db, {
        ingredientData
      });
      
      // Invalider le cache si l'opÃ©ration a rÃ©ussi et que queryClient est fourni
      if (result.success && queryClient && result.ingredientId) {
        logger.info(LogCategory.CACHE, `Invalidating cache after adding ingredient ${result.ingredientId}`);
        await invalidateCache(queryClient, DataType.INGREDIENT, { 
          id: result.ingredientId,
          invalidateRelated: true
        });
      }
      
      logger.endPerformanceLog('addIngredientViaMCP', startTime);
      return result;
    } catch (error) {
      logger.error(LogCategory.DATABASE, `Error in addIngredientViaMCP: ${error instanceof Error ? error.message : String(error)}`);
      logger.endPerformanceLog('addIngredientViaMCP', startTime);
      
      return {
        success: false,
        error: error instanceof Error ? error.message : String(error)
      };
    }
  }

  /**
   * RÃ©cupÃ¨re une liste d'ingrÃ©dients standards via le MCP server
   * @param search Terme de recherche (optionnel)
   * @param limit Nombre maximum d'ingrÃ©dients Ã  retourner (par dÃ©faut: 50)
   * @returns RÃ©sultat de l'opÃ©ration avec la liste des ingrÃ©dients
   */
  public async getIngredientsListViaMCP(
    search?: string,
    limit: number = 50
  ): Promise<GetIngredientsListResult> {
    const startTime = logger.startPerformanceLog('getIngredientsListViaMCP');
    
    try {
      if (!this.db) throw new Error("Database not initialized");
      
      logger.info(LogCategory.DATABASE, 'Getting ingredients list via MCP Server', {
        search: search || 'none',
        limit
      });
      
      // Appeler le handler avec les paramÃ¨tres
      const result = await handleGetIngredientsList(this.db, {
        search,
        limit
      });
      
      logger.endPerformanceLog('getIngredientsListViaMCP', startTime);
      return result;
    } catch (error) {
      logger.error(LogCategory.DATABASE, `Error in getIngredientsListViaMCP: ${error instanceof Error ? error.message : String(error)}`);
      logger.endPerformanceLog('getIngredientsListViaMCP', startTime);
      
      return {
        success: false,
        error: error instanceof Error ? error.message : String(error),
        ingredients: []
      };
    }
  }

  /**
   * Met Ã  jour un ingrÃ©dient standard via le MCP server
   * @param ingredientId ID de l'ingrÃ©dient Ã  mettre Ã  jour
   * @param data DonnÃ©es de l'ingrÃ©dient Ã  mettre Ã  jour
   * @param queryClient Client React Query pour l'invalidation du cache (optionnel)
   * @returns RÃ©sultat de l'opÃ©ration
   */
  public async updateIngredientViaMCP(
    ingredientId: number,
    data: Partial<typeof schema.ingredientsStandard.$inferSelect>,
    queryClient?: QueryClient
  ): Promise<UpdateIngredientResult> {
    const startTime = logger.startPerformanceLog('updateIngredientViaMCP');
    
    try {
      if (!this.db) throw new Error("Database not initialized");
      
      logger.info(LogCategory.DATABASE, `Updating ingredient with ID ${ingredientId} via MCP Server`);
      
      // Appeler le handler avec les paramÃ¨tres
      const result = await handleUpdateIngredient(this.db, {
        ingredientId,
        data
      });
      
      // Invalider le cache si l'opÃ©ration a rÃ©ussi et que queryClient est fourni
      if (result.success && queryClient) {
        logger.info(LogCategory.CACHE, `Invalidating cache after updating ingredient ${ingredientId}`);
        await invalidateCache(queryClient, DataType.INGREDIENT, { 
          id: ingredientId,
          invalidateRelated: true
        });
      }
      
      logger.endPerformanceLog('updateIngredientViaMCP', startTime);
      return result;
    } catch (error) {
      logger.error(LogCategory.DATABASE, `Error in updateIngredientViaMCP: ${error instanceof Error ? error.message : String(error)}`);
      logger.endPerformanceLog('updateIngredientViaMCP', startTime);
      
      return {
        success: false,
        error: error instanceof Error ? error.message : String(error)
      };
    }
  }

  /**
   * Supprime un ingrÃ©dient standard via le MCP server
   * @param ingredientId ID de l'ingrÃ©dient Ã  supprimer
   * @param queryClient Client React Query pour l'invalidation du cache (optionnel)
   * @returns RÃ©sultat de l'opÃ©ration
   */
  public async deleteIngredientViaMCP(
    ingredientId: number,
    queryClient?: QueryClient
  ): Promise<DeleteIngredientResult> {
    const startTime = logger.startPerformanceLog('deleteIngredientViaMCP');
    
    try {
      if (!this.db) throw new Error("Database not initialized");
      
      logger.info(LogCategory.DATABASE, `Deleting ingredient with ID ${ingredientId} via MCP Server`);
      
      // Appeler le handler avec les paramÃ¨tres
      const result = await handleDeleteIngredient(this.db, {
        ingredientId
      });
      
      // Invalider le cache si l'opÃ©ration a rÃ©ussi et que queryClient est fourni
      if (result.success && queryClient) {
        logger.info(LogCategory.CACHE, `Invalidating cache after deleting ingredient ${ingredientId}`);
        await invalidateCache(queryClient, DataType.INGREDIENTS_LIST, { 
          invalidateRelated: true
        });
      }
      
      logger.endPerformanceLog('deleteIngredientViaMCP', startTime);
      return result;
    } catch (error) {
      logger.error(LogCategory.DATABASE, `Error in deleteIngredientViaMCP: ${error instanceof Error ? error.message : String(error)}`);
      logger.endPerformanceLog('deleteIngredientViaMCP', startTime);
      
      return {
        success: false,
        error: error instanceof Error ? error.message : String(error)
      };
    }
  }

  /**
   * Met Ã  jour les prÃ©fÃ©rences utilisateur via le MCP server
   * @param userId ID de l'utilisateur Ã  mettre Ã  jour
   * @param preferences PrÃ©fÃ©rences Ã  mettre Ã  jour
   * @returns RÃ©sultat de l'opÃ©ration
   */
  public async updateUserPreferencesViaMCP(
    userId: number,
    preferences: Partial<{
      age: number;
      gender: string;
      weight: number;
      weightUnit: string;
      height: number;
      heightUnit: string;
      physicalActivity: string;
    }>
  ): Promise<UpdateUserPreferencesResult> {
    return handleUpdateUserPreferences(this.db, { userId, preferences });
  }
  
  /**
   * Met Ã  jour les prÃ©fÃ©rences nutritionnelles de l'utilisateur via le MCP server
   * (restrictions alimentaires, allergies, objectifs nutritionnels)
   * @param userId ID de l'utilisateur Ã  mettre Ã  jour
   * @param dietaryRestrictions Liste des restrictions alimentaires
   * @param allergies Liste des allergies
   * @param nutritionGoals Objectifs nutritionnels
   * @returns RÃ©sultat de l'opÃ©ration
   */
  public async updateUserNutritionPreferencesViaMCP(
    userId: number,
    dietaryRestrictions?: string[],
    allergies?: string[],
    nutritionGoals?: {
      goal?: string;
      targetWeight?: number;
      dailyCalories?: number;
      proteinPercentage?: number;
      carbsPercentage?: number;
      fatPercentage?: number;
    }
  ) {
    return handleUpdateUserNutritionPreferences(this.db, { 
      userId, 
      dietaryRestrictions, 
      allergies, 
      nutritionGoals 
    });
  }

  /**
   * CrÃ©e un nouveau repas avec ses ingrÃ©dients associÃ©s via le MCP server
   * @param data DonnÃ©es du formulaire de repas
   * @param selectedIngredients Liste des ingrÃ©dients sÃ©lectionnÃ©s
   * @param totalMacros Totaux des macronutriments calculÃ©s
   * @param creatorId ID de l'utilisateur crÃ©ateur
   * @returns RÃ©sultat de l'opÃ©ration avec l'ID du repas crÃ©Ã© ou une erreur
   */
  public async createNewMealViaMCP(
    data: any, // MealFormData (importation Ã©vitÃ©e pour simplifier)
    selectedIngredients: any[], // IngredientWithStandardProps[] (importation Ã©vitÃ©e pour simplifier)
    totalMacros: { totalCalories: number; totalCarbs: number; totalFats: number; totalProtein: number },
    creatorId: number
  ): Promise<CreateNewMealResult> {
    try {
      logger.info(LogCategory.DATABASE, `Creating new meal via MCP`);
      
      // Mesurer le temps d'accÃ¨s pour les logs de performance
      const startTime = performance.now();
      
      // Appel direct au handler
      const result = await handleCreateNewMeal(this.db, { data, selectedIngredients, totalMacros, creatorId });
      
      // Calculer le temps d'accÃ¨s pour les logs
      const accessTime = performance.now() - startTime;
      logger.debug(LogCategory.DATABASE, `Database access time for creating meal: ${accessTime.toFixed(2)}ms`);
      
      // L'invalidation du cache est dÃ©sormais gÃ©rÃ©e par React Query au niveau des composants
      
      return result;
    } catch (error) {
      logger.error(LogCategory.DATABASE, `Error creating meal via MCP: ${error}`);
      return {
        success: false,
        error: `Failed to create meal: ${error}`
      };
    }
  }

  /**
   * Ajoute un repas Ã  un plan journalier via le MCP server
   * @param dailyPlanId ID du plan journalier
   * @param mealId ID du repas Ã  ajouter
   * @param quantity QuantitÃ© du repas (par dÃ©faut: 10 grammes)
   * @param mealType Type spÃ©cifique du repas pour ce plan journalier (optionnel)
   * @returns RÃ©sultat de l'opÃ©ration
   */
  public async addMealToDailyPlanViaMCP(
    dailyPlanId: number,
    mealId: number,
    quantity: number = 10,
    mealType?: MealTypeEnum
  ): Promise<AddMealToDailyPlanResult> {
    const startTime = logger.startPerformanceLog('addMealToDailyPlanViaMCP');
    
    try {
      if (!this.db) throw new Error("Database not initialized");
      
      logger.info(LogCategory.DATABASE, 'Adding meal to daily plan via MCP Server', {
        dailyPlanId, mealId, quantity, mealType
      });
      
      // Appeler le handler avec les paramÃ¨tres
      const result = await handleAddMealToDailyPlanMealHandler(this.db, {
        dailyPlanId,
        mealId,
        quantity,
        mealType
      });
      
      logger.endPerformanceLog('addMealToDailyPlanViaMCP', startTime);
      return result;
    } catch (error) {
      logger.error(LogCategory.DATABASE, `Error in addMealToDailyPlanViaMCP: ${error instanceof Error ? error.message : String(error)}`);
      logger.endPerformanceLog('addMealToDailyPlanViaMCP', startTime);
      
      return {
        success: false,
        error: error instanceof Error ? error.message : String(error)
      };
    }
  }

  /**
   * RÃ©cupÃ¨re la quantitÃ© d'un repas dans un plan journalier
   * @param dailyPlanId ID du plan journalier
   * @param mealId ID du repas
   * @returns RÃ©sultat de l'opÃ©ration avec la quantitÃ©
   */
  public async getMealQuantityInPlanViaMCP(
    dailyPlanId: number,
    mealId: number
  ): Promise<GetMealQuantityInPlanResult> {
    const startTime = logger.startPerformanceLog('getMealQuantityInPlanViaMCP');
    
    try {
      if (!this.db) throw new Error("Database not initialized");
      
      logger.info(LogCategory.DATABASE, 'Getting meal quantity in plan via MCP Server', {
        dailyPlanId, mealId
      });
      
      // Appeler le handler avec les paramÃ¨tres
      const result = await handleGetMealQuantityInPlan(this.db, {
        dailyPlanId,
        mealId
      });
      
      logger.endPerformanceLog('getMealQuantityInPlanViaMCP', startTime);
      return result;
    } catch (error) {
      logger.error(LogCategory.DATABASE, `Error in getMealQuantityInPlanViaMCP: ${error instanceof Error ? error.message : String(error)}`);
      logger.endPerformanceLog('getMealQuantityInPlanViaMCP', startTime);
      
      return {
        success: false,
        error: error instanceof Error ? error.message : String(error)
      };
    }
  }

  /**
   * Met Ã  jour la quantitÃ© d'un repas dans un plan journalier
   * @param dailyPlanId ID du plan journalier
   * @param mealId ID du repas
   * @param newQuantity Nouvelle quantitÃ© du repas
   * @returns RÃ©sultat de l'opÃ©ration
   */
  public async updateMealQuantityInPlanViaMCP(
    dailyPlanId: number,
    mealId: number,
    newQuantity: number
  ): Promise<UpdateMealQuantityInPlanResult> {
    const startTime = logger.startPerformanceLog('updateMealQuantityInPlanViaMCP');
    
    try {
      if (!this.db) throw new Error("Database not initialized");
      
      logger.info(LogCategory.DATABASE, 'Updating meal quantity in plan via MCP Server', {
        dailyPlanId, mealId, newQuantity
      });
      
      // Appeler le handler avec les paramÃ¨tres
      const result = await handleUpdateMealQuantityInPlan(this.db, {
        dailyPlanId,
        mealId,
        newQuantity
      });
      
      logger.endPerformanceLog('updateMealQuantityInPlanViaMCP', startTime);
      return result;
    } catch (error) {
      logger.error(LogCategory.DATABASE, `Error in updateMealQuantityInPlanViaMCP: ${error instanceof Error ? error.message : String(error)}`);
      logger.endPerformanceLog('updateMealQuantityInPlanViaMCP', startTime);
      
      return {
        success: false,
        error: error instanceof Error ? error.message : String(error)
      };
    }
  }

  /**
   * DÃ©finit un plan comme Ã©tant le plan actuel d'un utilisateur
   * @param planId ID du plan Ã  dÃ©finir comme actuel
   * @param userId ID de l'utilisateur
   * @returns RÃ©sultat de l'opÃ©ration
   */
  public async setCurrentPlanViaMCP(
    planId: number,
    userId: number
  ): Promise<SetCurrentPlanResult> {
    const startTime = logger.startPerformanceLog('setCurrentPlanViaMCP');
    
    try {
      if (!this.db) throw new Error("Database not initialized");
      
      logger.info(LogCategory.DATABASE, 'Setting current plan via MCP Server', {
        planId, userId
      });
      
      // Appeler le handler avec les paramÃ¨tres
      const result = await handleSetCurrentPlan(this.db, {
        planId,
        userId
      });
      
      logger.endPerformanceLog('setCurrentPlanViaMCP', startTime);
      return result;
    } catch (error) {
      logger.error(LogCategory.DATABASE, `Error in setCurrentPlanViaMCP: ${error instanceof Error ? error.message : String(error)}`);
      logger.endPerformanceLog('setCurrentPlanViaMCP', startTime);
      
      return {
        success: false,
        error: error instanceof Error ? error.message : String(error)
      };
    }
  }

  /**
   * RÃ©cupÃ¨re le plan actuel d'un utilisateur
   * @param userId ID de l'utilisateur
   * @returns RÃ©sultat de l'opÃ©ration avec le plan actuel
   */
  public async getCurrentPlanViaMCP(
    userId: number
  ): Promise<GetCurrentPlanResult> {
    const startTime = logger.startPerformanceLog('getCurrentPlanViaMCP');
    
    try {
      if (!this.db) throw new Error("Database not initialized");
      
      logger.info(LogCategory.DATABASE, 'Getting current plan via MCP Server', {
        userId
      });
      
      // Appeler le handler avec les paramÃ¨tres
      const result = await handleGetCurrentPlan(this.db, {
        userId
      });
      
      logger.endPerformanceLog('getCurrentPlanViaMCP', startTime);
      return result;
    } catch (error) {
      logger.error(LogCategory.DATABASE, `Error in getCurrentPlanViaMCP: ${error instanceof Error ? error.message : String(error)}`);
      logger.endPerformanceLog('getCurrentPlanViaMCP', startTime);
      
      return {
        success: false,
        error: error instanceof Error ? error.message : String(error)
      };
    }
  }

  /**
   * Retourne la liste des plans pour un utilisateur spÃ©cifique
   * @param userId ID de l'utilisateur dont on veut rÃ©cupÃ©rer les plans
   * @returns Liste des plans
   */
  public async getPlansListViaMCP(userId: number) {
    try {
      if (!userId) {
        logger.error(LogCategory.DATABASE, `Missing userId in getPlansListViaMCP`);
        return { success: false, error: 'Missing required userId parameter' };
      }
      
      logger.info(LogCategory.DATABASE, `Getting plans list via MCP for user ${userId}`);
      
      // Mesurer le temps d'accÃ¨s pour les logs de performance
      const startTime = performance.now();
      
      // Appel direct au handler
      const result = await handleGetPlansList(this.db, { userId });
      
      // Calculer le temps d'accÃ¨s pour les logs
      const accessTime = performance.now() - startTime;
      logger.debug(LogCategory.DATABASE, `Database access time for plans list: ${accessTime.toFixed(2)}ms`);
      
      return result;
    } catch (error) {
      logger.error(LogCategory.DATABASE, `Error getting plans list via MCP: ${error}`);
      return {
        success: false,
        error: `Failed to get plans list: ${error}`
      };
    }
  }

  /**
   * CrÃ©e un nouveau plan nutritionnel via le MCP server
   * @param data DonnÃ©es du plan Ã  crÃ©er (formulaire NutritionGoalSchema)
   * @param userId ID de l'utilisateur propriÃ©taire du plan
   * @returns RÃ©sultat de l'opÃ©ration avec l'ID du plan crÃ©Ã©
   */
  public async createPlanViaMCP(data: NutritionGoalSchemaFormData, userId: number) {
    return handleCreatePlan(this.db, { data, userId });
  }

  /**
   * Met Ã  jour un plan nutritionnel existant via le MCP server
   * @param planId ID du plan Ã  mettre Ã  jour
   * @param data DonnÃ©es du plan Ã  mettre Ã  jour
   * @param userId ID de l'utilisateur propriÃ©taire du plan
   * @returns RÃ©sultat de l'opÃ©ration
   */
  public async updatePlanViaMCP(planId: number, data: Partial<PlanOrmProps>, userId: number): Promise<BasicResult> {
    try {
      if (!this.db) throw new Error("Database not initialized");
      
      logger.info(LogCategory.DATABASE, `Updating plan ${planId} via MCP Server`);
      
      // Appeler le handler avec les paramÃ¨tres
      const result = await handleUpdatePlan(this.db, { planId, data, userId });
      
      return result;
    } catch (error) {
      logger.error(LogCategory.DATABASE, `Error in updatePlanViaMCP: ${error instanceof Error ? error.message : String(error)}`);
      return { 
        success: false, 
        error: error instanceof Error ? error.message : String(error) 
      };
    }
  }

  /**
   * Supprime un plan nutritionnel via le MCP server
   * @param planId ID du plan Ã  supprimer
   * @param userId ID de l'utilisateur propriÃ©taire du plan
   * @returns RÃ©sultat de l'opÃ©ration
   */
  public async deletePlanViaMCP(planId: number, userId: number): Promise<DeletePlanResult> {
    try {
      if (!this.db) throw new Error("Database not initialized");
      
      logger.info(LogCategory.DATABASE, `Deleting plan ${planId} via MCP Server`);
      
      // Appeler le handler avec les paramÃ¨tres
      const result = await handleDeletePlan(this.db, { planId, userId });
      
      return result;
    } catch (error) {
      logger.error(LogCategory.DATABASE, `Error in deletePlanViaMCP: ${error instanceof Error ? error.message : String(error)}`);
      return { 
        success: false, 
        error: error instanceof Error ? error.message : String(error) 
      };
    }
  }

  /**
   * Obtient les dÃ©tails d'un plan avec ses plans journaliers
   * @param planId ID du plan
   * @param userId ID de l'utilisateur (pour sÃ©curiser l'accÃ¨s aux donnÃ©es)
   * @returns DÃ©tails du plan avec ses plans journaliers
   */
  public async getPlanDetailsViaMCP(planId: number | string, userId: number) {
    if (!userId) {
      logger.error(LogCategory.DATABASE, `Missing userId in getPlanDetailsViaMCP`);
      return { success: false, error: 'Missing required userId parameter' };
    }
    return handleGetPlanDetails(this.db, { planId, userId });
  }

  /**
   * RÃ©cupÃ¨re un plan nutritionnel avec ses plans journaliers (sans les repas)
   * @param planId ID du plan
   * @returns Plan avec ses plans journaliers sans les repas
   */
  public async getPlanWithDailyPlansViaMCP(planId: number) {
    // Stub - sera implÃ©mentÃ© avec les handlers de plans
    return { 
      success: true, 
      plan: null, 
      dailyPlans: [],
      error: null 
    };
  }



  /**
   * Retourne les dÃ©tails d'un repas avec ses ingrÃ©dients
   * @param mealId ID du repas
   * @param userId ID de l'utilisateur (pour sÃ©curiser l'accÃ¨s aux donnÃ©es)
   * @returns DÃ©tails du repas avec ses ingrÃ©dients
   */
  public async getMealByIdWithIngredientsViaMCP(mealId: number, userId?: number) {
    try {
      logger.info(LogCategory.DATABASE, `Getting meal ${mealId} with ingredients via MCP`);
      
      // Mesurer le temps d'accÃ¨s pour les logs de performance
      const startTime = performance.now();
      
      // Passer userId au handler pour garantir l'isolation des donnÃ©es entre utilisateurs
      const result = await handleGetMealDetails(this.db, { mealId, userId });
      
      // Calculer le temps d'accÃ¨s pour les logs
      const accessTime = performance.now() - startTime;
      logger.debug(LogCategory.DATABASE, `Database access time for meal details: ${accessTime.toFixed(2)}ms`);
      
      return result;
    } catch (error) {
      logger.error(LogCategory.DATABASE, `Error getting meal by id via MCP: ${error}`);
      return {
        success: false,
        error: `Failed to get meal by id: ${error}`
      };
    }
  }

  /**
   * Met Ã  jour un repas via le serveur MCP
   * @param mealId ID du repas Ã  mettre Ã  jour
   * @param data DonnÃ©es du repas Ã  mettre Ã  jour
   * @param ingredients IngrÃ©dients du repas (optionnel)
   * @param userId ID de l'utilisateur propriÃ©taire du repas
   * @returns RÃ©sultat de l'opÃ©ration
   */
  public async updateMealViaMCP(mealId: number, data: Partial<MealOrmProps>, ingredients?: any[], userId?: number) {
    try {
      if (!this.db) throw new Error("Database not initialized");
      
      // S'assurer que userId est fourni (si non, utiliser le creatorId des donnÃ©es ou lancer une erreur)
      const authenticatedUserId = userId || data.creatorId;
      if (!authenticatedUserId) {
        throw new Error("User ID is required for updating a meal");
      }
      
      logger.info(LogCategory.DATABASE, `Updating meal ${mealId} via MCP Server for user ${authenticatedUserId}`);
      
      // Appeler le handler avec les paramÃ¨tres
      const result = await handleUpdateMeal(this.db, { 
        mealId, 
        data, 
        ingredients, 
        userId: authenticatedUserId 
      });
      
      return result;
    } catch (error) {
      logger.error(LogCategory.DATABASE, `Error in updateMealViaMCP: ${error instanceof Error ? error.message : String(error)}`);
      return { 
        success: false, 
        error: error instanceof Error ? error.message : String(error) 
      };
    }
  }
  
  /**
   * Supprime un repas via le serveur MCP
   * @param mealId ID du repas Ã  supprimer
   * @param userId ID de l'utilisateur
   * @returns RÃ©sultat de l'opÃ©ration
   */
  public async deleteMealViaMCP(mealId: number, userId: number) {
    try {
      if (!this.db) throw new Error("Database not initialized");
      
      if (!userId) {
        throw new Error("User ID is required for deleting a meal");
      }
      
      logger.info(LogCategory.DATABASE, `Deleting meal ${mealId} via MCP Server for user ${userId}`);
      
      // Mesurer le temps d'accÃ¨s pour les logs de performance
      const startTime = performance.now();
      
      // Appeler le handler avec les paramÃ¨tres
      const result = await handleDeleteMeal(this.db, { mealId, userId });
      
      // Calculer le temps d'accÃ¨s pour les logs
      const accessTime = performance.now() - startTime;
      logger.debug(LogCategory.DATABASE, `Database access time for deleting meal: ${accessTime.toFixed(2)}ms`);
      
      return result;
    } catch (error) {
      logger.error(LogCategory.DATABASE, `Error deleting meal via MCP: ${error}`);
      return {
        success: false,
        error: `Failed to delete meal: ${error}`
      };
    }
  }

  /**
   * RÃ©cupÃ¨re les dÃ©tails d'un utilisateur via le MCP server
   * @param userId ID de l'utilisateur
   * @returns RÃ©sultat de l'opÃ©ration avec les dÃ©tails de l'utilisateur ou une erreur
   */
  public async getUserDetailsViaMCP(
    userId: number
  ): Promise<GetUserDetailsResult> {
    try {
      logger.info(LogCategory.DATABASE, `Getting user details for user ${userId} via MCP`);
      
      // Appeler le handler handleGetUserDetails avec mesure de performance
      const startTime = logger.startPerformanceLog('getUserDetailsViaMCP');
      const result = await handleGetUserDetails(this.db, { userId });
      const endTime = logger.endPerformanceLog('getUserDetailsViaMCP', startTime);
      
      return result;
    } catch (error) {
      logger.error(LogCategory.DATABASE, `Error getting user details via MCP: ${error}`);
      return {
        success: false,
        error: `Failed to get user details: ${error}`
      };
    }
  }

  /**
   * CrÃ©e un nouvel utilisateur via le MCP server
   * @param userData DonnÃ©es de l'utilisateur Ã  crÃ©er
   * @returns RÃ©sultat de l'opÃ©ration avec l'ID de l'utilisateur crÃ©Ã© ou une erreur
   */
  public async createUserViaMCP(
    userData: Omit<typeof schema.users.$inferSelect, 'id'>
  ): Promise<CreateUserResult> {
    logger.info(LogCategory.DATABASE, `Creating new user via MCP`);
    return handleCreateUser(this.db, { data: userData });
  }

  /**
   * RÃ©cupÃ¨re la progression quotidienne pour une date spÃ©cifique via le MCP server
   * @param userId ID de l'utilisateur
   * @param date Date au format YYYY-MM-DD
   * @returns RÃ©sultat de l'opÃ©ration avec la progression quotidienne ou une erreur
   */
  public async getDailyProgressByDateViaMCP(
    userId: number,
    date: string
  ): Promise<GetDailyProgressByDateResult> {
    logger.info(LogCategory.DATABASE, `Getting daily progress for date ${date} via MCP`);
    return handleGetDailyProgressByDate(this.db, { userId, date });
  }

  /**
   * CrÃ©e une nouvelle progression quotidienne via le MCP server
   * @param userId ID de l'utilisateur
   * @param date Date au format YYYY-MM-DD
   * @returns RÃ©sultat de l'opÃ©ration avec la progression quotidienne crÃ©Ã©e ou une erreur
   */
  public async createDailyProgressViaMCP(
    userId: number,
    date: string
  ): Promise<CreateDailyProgressResult> {
    logger.info(LogCategory.DATABASE, `Creating daily progress for date ${date} via MCP`);
    return handleCreateDailyProgress(this.db, { userId, date });
  }

  /**
   * Met Ã  jour une progression quotidienne via le MCP server
   * @param progressId ID de la progression Ã  mettre Ã  jour
   * @param data DonnÃ©es de la progression Ã  mettre Ã  jour
   * @returns RÃ©sultat de l'opÃ©ration avec la progression quotidienne mise Ã  jour ou une erreur
   */
  public async updateDailyProgressViaMCP(
    progressId: number,
    data: Partial<typeof schema.dailyProgress.$inferSelect>
  ): Promise<UpdateDailyProgressResult> {
    logger.info(LogCategory.DATABASE, `Updating daily progress ${progressId} via MCP`);
    return handleUpdateDailyProgress(this.db, { progressId, data });
  }

  /**
   * RÃ©cupÃ¨re les repas avec leur Ã©tat de progression pour une date spÃ©cifique via le MCP server
   * @param userId ID de l'utilisateur
   * @param date Date au format YYYY-MM-DD
   * @returns RÃ©sultat de l'opÃ©ration avec les repas et leur progression ou une erreur
   */
  public async getMealProgressByDateViaMCP(
    userId: number,
    date: string
  ): Promise<GetMealProgressByDateResult> {
    logger.info(LogCategory.DATABASE, `Getting meal progress for date ${date} via MCP`);
    return handleGetMealProgressByDate(this.db, { userId, date });
  }

  /**
   * Marque un repas comme consommÃ© ou non via le MCP server
   * @param dailyProgressId ID de la progression quotidienne
   * @param mealId ID du repas
   * @param dailyPlanMealId ID du repas dans le plan quotidien
   * @param consumed Indique si le repas a Ã©tÃ© consommÃ©
   * @param pourcentageConsomme Pourcentage du repas consommÃ© (par dÃ©faut: 100)
   * @returns RÃ©sultat de l'opÃ©ration avec la progression du repas ou une erreur
   */
  public async markMealAsConsumedViaMCP(
    dailyProgressId: number,
    mealId: number,
    dailyPlanMealId: number,
    consumed: boolean,
    pourcentageConsomme: number = 100
  ): Promise<MarkMealAsConsumedResult> {
    logger.info(LogCategory.DATABASE, `Marking meal ${mealId} as ${consumed ? 'consumed' : 'not consumed'} via MCP`);
    return handleMarkMealAsConsumed(this.db, { dailyProgressId, mealId, dailyPlanMealId, consumed, pourcentageConsomme });
  }

  /**
   * RÃ©cupÃ¨re les progrÃ¨s pour une progression quotidienne spÃ©cifique via le MCP server
   * @param dailyProgressId ID de la progression quotidienne
   * @returns RÃ©sultat de l'opÃ©ration avec les progrÃ¨s des repas ou une erreur
   */
  public async getMealProgressByDailyProgressViaMCP(
    dailyProgressId: number
  ): Promise<GetMealProgressByDailyProgressResult> {
    logger.info(LogCategory.DATABASE, `Getting meal progress for daily progress ${dailyProgressId} via MCP`);
    return handleGetMealProgressByDailyProgress(this.db, { dailyProgressId });
  }

  /**
   * VÃ©rifie si un utilisateur existe via le MCP server
   * @param userId ID de l'utilisateur Ã  vÃ©rifier
   * @returns RÃ©sultat de l'opÃ©ration indiquant si l'utilisateur existe
   */
  public async validateUserExistsViaMCP(
    userId: number
  ): Promise<ValidateUserExistsResult> {
    logger.info(LogCategory.DATABASE, `Validating user existence via MCP: ${userId}`);
    return handleValidateUserExists(this.db, { userId });
  }

  /**
   * Trouve un utilisateur par email via le MCP server sans le crÃ©er s'il n'existe pas
   * @param email Email de l'utilisateur
   * @returns RÃ©sultat de l'opÃ©ration avec l'utilisateur trouvÃ© ou une erreur
   */
  public async findUserByEmailViaMCP(email: string): Promise<{ success: boolean; user?: any; error?: string }> {
    logger.info(LogCategory.DATABASE, `Finding user by email via MCP: ${email}`);
    try {
      if (!this.db) throw new Error("Database not initialized");
      
      // Rechercher l'utilisateur par email
      logger.info(LogCategory.DATABASE, `Searching user by email: ${email}`);
      const existingUser = await this.db
        .select()
        .from(users)
        .where(eq(users.email, email))
        .limit(1);
      
      if (existingUser.length > 0) {
        logger.info(LogCategory.DATABASE, `User found by email: ${email}`);
        return { success: true, user: existingUser[0] };
      }
      
      // Si l'utilisateur n'existe pas, retourner une erreur
      logger.info(LogCategory.DATABASE, `User not found by email: ${email}`);
      return { success: false, error: `User with email ${email} not found` };
    } catch (error) {
      logger.error(LogCategory.DATABASE, `Error in findUserByEmailViaMCP: ${error instanceof Error ? error.message : String(error)}`);
      return { 
        success: false, 
        error: error instanceof Error ? error.message : String(error) 
      };
    }
  }

  /**
   * Trouve ou crÃ©e un utilisateur via le MCP server
   * @param email Email de l'utilisateur
   * @returns RÃ©sultat de l'opÃ©ration avec l'utilisateur trouvÃ© ou crÃ©Ã©
   */
  public async findOrCreateUserViaMCP(
    email: string,
    clerkId?: string
  ): Promise<{ success: boolean; user?: any; error?: string }> {
    logger.info(LogCategory.DATABASE, `Finding or creating user via MCP: ${email}`);
    try {
      if (!this.db) throw new Error("Database not initialized");
      
      // VÃ©rifier si l'utilisateur existe dÃ©jÃ , d'abord par clerkId si disponible, sinon par email
      let existingUser;
      
      if (clerkId) {
        // Recherche par clerkId (mÃ©thode prÃ©fÃ©rÃ©e car plus fiable)
        logger.info(LogCategory.DATABASE, `Searching user by clerkId: ${clerkId}`);
        existingUser = await this.db
          .select()
          .from(users)
          .where(eq(users.clerkId, clerkId))
          .limit(1);
          
        if (existingUser.length > 0) {
          logger.info(LogCategory.DATABASE, `User found by clerkId: ${clerkId}`);
          return { success: true, user: existingUser[0] };
        }
      }
      
      // Si l'utilisateur n'a pas Ã©tÃ© trouvÃ© par clerkId, rechercher par email
      logger.info(LogCategory.DATABASE, `Searching user by email: ${email}`);
      existingUser = await this.db
        .select()
        .from(users)
        .where(eq(users.email, email))
        .limit(1);
      
      if (existingUser.length > 0) {
        logger.info(LogCategory.DATABASE, `User found by email: ${email}`);
        
        // Si l'utilisateur existe par email mais n'a pas encore de clerkId, mettre Ã  jour avec le nouveau clerkId
        if (clerkId && !existingUser[0].clerkId) {
          logger.info(LogCategory.DATABASE, `Updating existing user with clerkId: ${clerkId}`);
          await this.db
            .update(users)
            .set({ clerkId, updatedAt: new Date().toISOString() })
            .where(eq(users.id, existingUser[0].id));
          
          // RÃ©cupÃ©rer l'utilisateur mis Ã  jour
          const updatedUser = await this.db
            .select()
            .from(users)
            .where(eq(users.id, existingUser[0].id))
            .limit(1);
            
          if (updatedUser.length > 0) {
            return { success: true, user: updatedUser[0] };
          }
        }
        
        return { success: true, user: existingUser[0] };
      }
      
      // CrÃ©er un nouvel utilisateur avec des donnÃ©es par dÃ©faut
      // Remarque: nous utilisons directement la base de donnÃ©es pour Ã©viter les problÃ¨mes de typage
      // avec createUserViaMCP qui attend tous les champs requis
      const userData = {
        email,
        name: email.split('@')[0], // Nom par dÃ©faut basÃ© sur l'email
        gender: 'MALE', // Valeur par dÃ©faut
        provider: 'EMAIL', // Valeur par dÃ©faut
        role: 'USER', // Valeur par dÃ©faut
        age: 30, // Valeur par dÃ©faut
        weight: 70, // Valeur par dÃ©faut
        height: 175, // Valeur par dÃ©faut
        physicalActivity: 'MODERATELY_ACTIVE', // Valeur par dÃ©faut
        createdAt: new Date().toISOString(),
        updatedAt: new Date().toISOString(),
        clerkId: clerkId || null // Inclure l'ID Clerk s'il est disponible
      };
      
      // Log pour debug
      if (clerkId) {
        logger.info(LogCategory.DATABASE, `Creating new user with clerkId: ${clerkId}`);
      } else {
        logger.info(LogCategory.DATABASE, `Creating new user without clerkId`);
      }
      
      // InsÃ©rer directement l'utilisateur dans la base de donnÃ©es
      const [insertedUser] = await this.db
        .insert(users)
        .values(userData)
        .returning({ id: users.id });
        
      if (!insertedUser) {
        throw new Error('Failed to create user');
      }
      
      const userId = insertedUser.id;
      
      // RÃ©cupÃ©rer l'utilisateur nouvellement crÃ©Ã©
      const newUser = await this.getUserDetailsViaMCP(userId);
      
      if (!newUser.success) {
        throw new Error(newUser.error);
      }
      
      logger.info(LogCategory.DATABASE, `New user created: ${email}`);
      return { success: true, user: newUser.user };
    } catch (error) {
      logger.error(LogCategory.DATABASE, `Error in findOrCreateUserViaMCP: ${error instanceof Error ? error.message : String(error)}`);
      return { 
        success: false, 
        error: error instanceof Error ? error.message : String(error) 
      };
    }
  }

  /**
   * RÃ©cupÃ¨re les progressions quotidiennes associÃ©es Ã  un plan via le MCP server
   * @param userId ID de l'utilisateur
   * @param planId ID du plan
   * @returns RÃ©sultat de l'opÃ©ration avec les progressions quotidiennes ou une erreur
   */
  public async getDailyProgressByPlanViaMCP(
    userId: number,
    planId: number
  ): Promise<GetDailyProgressByPlanResult> {
    try {
      if (!this.db) throw new Error("Database not initialized");
      
      const result = await handleGetDailyProgressByPlan(this.db, { userId, planId });
      return result;
    } catch (error) {
      logger.error(LogCategory.DATABASE, `Error in getDailyProgressByPlanViaMCP: ${error instanceof Error ? error.message : String(error)}`);
      return { 
        success: false, 
        error: error instanceof Error ? error.message : String(error) 
      };
    }
  }

  /**
   * Get a default user or a specific user by ID if provided
   * @param userId Optional user ID to try first
   * @returns Result with the user or error
   */
  public async getDefaultUserViaMCP(userId?: number): Promise<GetDefaultUserResult> {
    const startTime = logger.startPerformanceLog('getDefaultUserViaMCP');
    
    try {
      if (!this.db) throw new Error("Database not initialized");
      
      logger.info(LogCategory.DATABASE, 'Getting default user via MCP Server', { userId });
      
      // Construire les paramÃ¨tres pour le handler
      const params: GetDefaultUserParams = {};
      if (userId) {
        params.userId = userId;
      }
      
         // Appeler le handler avec les paramÃ¨tres
         const result = await handleGetDefaultUser(this.db, params);
      
         logger.endPerformanceLog('getDefaultUserViaMCP',startTime);
         return result;
       } catch (error) {
         logger.error(LogCategory.DATABASE, `Error in getDefaultUserViaMCP: ${error instanceof Error ? error.message : String(error)}`);
         logger.endPerformanceLog('getDefaultUserViaMCP',startTime );
         
         return {
           success: false,
           error: error instanceof Error ? error.message : String(error)
         };
    }
  }

  /**
   * Retire un repas d'un plan journalier sans le supprimer de la base de donnÃ©es
   * @param dailyPlanId ID du plan journalier
   * @param mealId ID du repas Ã  retirer
   * @returns RÃ©sultat de l'opÃ©ration
   */
  public async removeMealFromDailyPlanViaMCP(dailyPlanId: number, mealId: number) {
    try {
      if (!this.db) throw new Error("Database not initialized");
      
      logger.info(LogCategory.DATABASE, `Removing meal ${mealId} from daily plan ${dailyPlanId} via MCP Server`);
      
      // Mesurer le temps d'accÃ¨s pour les logs de performance
      const startTime = performance.now();
      
      // Appeler le handler avec les paramÃ¨tres
      const result = await handleRemoveMealFromDailyPlan(this.db, { dailyPlanId, mealId });
      
      // Calculer le temps d'accÃ¨s pour les logs
      const accessTime = performance.now() - startTime;
      logger.debug(LogCategory.DATABASE, `Database access time for removing meal from plan: ${accessTime.toFixed(2)}ms`);
      
      return result;
    } catch (error) {
      logger.error(LogCategory.DATABASE, `Error removing meal from plan via MCP: ${error}`);
      return { success: false, error: `Error removing meal from plan: ${error instanceof Error ? error.message : String(error)}` };
    }
  }

  /**
   * Ajoute un plan journalier Ã  un plan nutritionnel existant
   * @param planId ID du plan nutritionnel parent
   * @param dailyPlanData DonnÃ©es du plan journalier Ã  ajouter
   * @returns RÃ©sultat de l'opÃ©ration avec l'ID du plan journalier crÃ©Ã© ou une erreur
   */
  public async addDailyPlanViaMCP(
    planId: number,
    dailyPlanData: {
      day: string;
      week?: number;
      calories: number;
      carbs: number;
      protein: number;
      fat: number;
    }
  ): Promise<AddDailyPlanResult> {
    try {
      if (!this.db) throw new Error("Database not initialized");
      
      logger.info(LogCategory.DATABASE, `Adding daily plan for day ${dailyPlanData.day} to plan ${planId} via MCP Server`);
      
      // Mesurer le temps d'accÃ¨s pour les logs de performance
      const startTime = performance.now();
      
      // Appeler le handler avec les paramÃ¨tres
      const params: AddDailyPlanParams = {
        planId,
        dailyPlanData
      };
      
      const result = await handleAddDailyPlan(this.db, params);
      
      // Calculer le temps d'accÃ¨s pour les logs
      const accessTime = performance.now() - startTime;
      logger.debug(LogCategory.DATABASE, `Database access time for adding daily plan: ${accessTime.toFixed(2)}ms`);
      
      return result;
    } catch (error) {
      logger.error(LogCategory.DATABASE, `Error in addDailyPlanViaMCP: ${error instanceof Error ? error.message : String(error)}`);
      return { 
        success: false, 
        error: error instanceof Error ? error.message : String(error) 
      };
    }
  }

  /**
   * GÃ©nÃ¨re un contexte utilisateur formatÃ© pour l'IA via le MCP server
   * @param userId ID de l'utilisateur
   * @returns RÃ©sultat de l'opÃ©ration avec le contexte utilisateur ou une erreur
   */
  public async generateUserContextViaMCP(userId: number): Promise<string> {
    try {
      if (!this.db) throw new Error("Database not initialized");
      
      logger.info(LogCategory.DATABASE, `Generating user context for user ${userId} via MCP Server`);
      
      // Mesurer le temps d'accÃ¨s pour les logs de performance
      const startTime = performance.now();
      
      // Appeler le handler avec les paramÃ¨tres
      const result = await handleGenerateUserContext(this.db, { userId });
      
      // Calculer le temps d'accÃ¨s pour les logs
      const accessTime = performance.now() - startTime;
      logger.debug(LogCategory.DATABASE, `Database access time for generating user context: ${accessTime.toFixed(2)}ms`);
      
      if (!result.success) {
        throw new Error(result.error || `Failed to generate context for user ${userId}`);
      }
      
      return result.context || '';
    } catch (error) {
      logger.error(LogCategory.DATABASE, `Error in generateUserContextViaMCP: ${error instanceof Error ? error.message : String(error)}`);
      // Retourner un contexte minimal en cas d'erreur pour Ã©viter les erreurs en cascade
      return `USER_ID: ${userId}\nNOTE: Error retrieving complete user context`;
    }
  }

  /**
   * GÃ©nÃ¨re un contexte utilisateur complet pour l'IA via le MCP server
   * @param userId ID de l'utilisateur
   * @returns RÃ©sultat de l'opÃ©ration avec le contexte utilisateur ou une erreur
   */
  public async getUserContextViaMCP(userId: number): Promise<GetUserContextResult> {
    try {
      if (!this.db) throw new Error("Database not initialized");
      
      logger.info(LogCategory.DATABASE, `Getting user context for user ${userId} via MCP Server`);
      
      // Mesurer le temps d'accÃ¨s pour les logs de performance
      const startTime = performance.now();
      
      // Appeler le handler avec les paramÃ¨tres
      const result = await handleGetUserContext(this.db, { userId });
      
      // Calculer le temps d'accÃ¨s pour les logs
      const accessTime = performance.now() - startTime;
      logger.debug(LogCategory.DATABASE, `Database access time for getting user context: ${accessTime.toFixed(2)}ms`);
      
      return result;
    } catch (error) {
      logger.error(LogCategory.DATABASE, `Error in getUserContextViaMCP: ${error instanceof Error ? error.message : String(error)}`);
      return { 
        success: false, 
        error: error instanceof Error ? error.message : String(error)
      };
    }
  }

  /**
   * RÃ©cupÃ¨re les prÃ©fÃ©rences d'un utilisateur via le MCP server
   * @param userId ID de l'utilisateur
   * @returns RÃ©sultat de l'opÃ©ration avec les prÃ©fÃ©rences utilisateur ou une erreur
   */
  public async getUserPreferencesViaMCP(userId: number): Promise<GetUserPreferencesResult> {
    try {
      if (!this.db) throw new Error("Database not initialized");
      
      logger.info(LogCategory.DATABASE, `Getting user preferences for user ${userId} via MCP Server`);
      
      // Mesurer le temps d'accÃ¨s pour les logs de performance
      const startTime = performance.now();
      
      // Appeler le handler avec les paramÃ¨tres
      const result = await handleGetUserPreferences(this.db, { userId });
      
      // Calculer le temps d'accÃ¨s pour les logs
      const accessTime = performance.now() - startTime;
      logger.debug(LogCategory.DATABASE, `Database access time for getting user preferences: ${accessTime.toFixed(2)}ms`);
      
      return result;
    } catch (error) {
      logger.error(LogCategory.DATABASE, `Error in getUserPreferencesViaMCP: ${error instanceof Error ? error.message : String(error)}`);
      return { 
        success: false, 
        error: error instanceof Error ? error.message : String(error)
      };
    }
  }

  /**
   * Retrieves the favorite meals of a user via the MCP server.
   * @param userId The ID of the user whose favorite meals are to be fetched.
   * @returns A promise that resolves to the result of the operation, containing the favorite meals or an error.
   */
  public async getUserFavoriteMealsViaMCP(userId: number): Promise<GetUserFavoriteMealsResult> {
    try {
      if (!this.db) throw new Error("Database not initialized");
      
      logger.info(LogCategory.DATABASE, `Getting favorite meals for user ${userId} via MCP Server`);
      
      // Mesurer le temps d'accÃ¨s pour les logs de performance
      const startTime = performance.now();
      
      // Appeler le handler avec les paramÃ¨tres
      const result = await handleGetUserFavoriteMeals(this.db, { userId });
      
      // Calculer le temps d'accÃ¨s pour les logs
      const accessTime = performance.now() - startTime;
      logger.debug(LogCategory.DATABASE, `Database access time for getting favorite meals: ${accessTime.toFixed(2)}ms`);
      
      return result;
    } catch (error) {
      logger.error(LogCategory.DATABASE, `Error in getUserFavoriteMealsViaMCP: ${error instanceof Error ? error.message : String(error)}`);
      return { 
        success: false, 
        error: error instanceof Error ? error.message : String(error)
      };
    }
  }

  /**
   * RÃ©cupÃ¨re les plans actifs d'un utilisateur via le MCP server
   * @param userId ID de l'utilisateur
   * @returns RÃ©sultat de l'opÃ©ration avec les plans actifs ou une erreur
   */
  public async getUserActivePlansViaMCP(userId: number): Promise<GetUserActivePlansResult> {
    try {
      if (!this.db) throw new Error("Database not initialized");
      
      logger.info(LogCategory.DATABASE, `Getting active plans for user ${userId} via MCP Server`);
      
      // Mesurer le temps d'accÃ¨s pour les logs de performance
      const startTime = performance.now();
      
      // Appeler le handler avec les paramÃ¨tres
      const result = await handleGetUserActivePlans(this.db, { userId });
      
      // Calculer le temps d'accÃ¨s pour les logs
      const accessTime = performance.now() - startTime;
      logger.debug(LogCategory.DATABASE, `Database access time for getting active plans: ${accessTime.toFixed(2)}ms`);
      
      return result;
    } catch (error) {
      logger.error(LogCategory.DATABASE, `Error in getUserActivePlansViaMCP: ${error instanceof Error ? error.message : String(error)}`);
      return { 
        success: false, 
        error: error instanceof Error ? error.message : String(error)
      };
    }
  }

  /**
   * RÃ©cupÃ¨re l'historique d'activitÃ© d'un utilisateur via le MCP server
   * @param userId ID de l'utilisateur
   * @param daysLimit Nombre de jours Ã  inclure (par dÃ©faut: 7)
   * @returns RÃ©sultat de l'opÃ©ration avec l'historique d'activitÃ© ou une erreur
   */
  public async getUserActivityHistoryViaMCP(userId: number, daysLimit: number = 7): Promise<GetUserActivityHistoryResult> {
    try {
      if (!this.db) throw new Error("Database not initialized");
      
      logger.info(LogCategory.DATABASE, `Getting activity history for user ${userId} via MCP Server`);
      
      // Mesurer le temps d'accÃ¨s pour les logs de performance
      const startTime = performance.now();
      
      // Appeler le handler avec les paramÃ¨tres
      const result = await handleGetUserActivityHistory(this.db, { userId, daysLimit });
      
      // Calculer le temps d'accÃ¨s pour les logs
      const accessTime = performance.now() - startTime;
      logger.debug(LogCategory.DATABASE, `Database access time for getting activity history: ${accessTime.toFixed(2)}ms`);
      
      return result;
    } catch (error) {
      logger.error(LogCategory.DATABASE, `Error in getUserActivityHistoryViaMCP: ${error instanceof Error ? error.message : String(error)}`);
      return { 
        success: false, 
        error: error instanceof Error ? error.message : String(error)
      };
    }
  }

  /**
   * Sauvegarde un conseil nutritionnel gÃ©nÃ©rÃ© par l'IA
   * @param params ParamÃ¨tres du conseil Ã  sauvegarder
   * @returns RÃ©sultat de l'opÃ©ration
   */
  public async saveNutritionAdviceViaMCP(params: SaveNutritionAdviceParams): Promise<SaveNutritionAdviceResult> {
    try {
      if (!this.db) throw new Error("Database not initialized");
      
      logger.info(LogCategory.DATABASE, `Saving nutrition advice for user ${params.userId} via MCP Server`);
      
      // Mesurer le temps d'accÃ¨s pour les logs de performance
      const startTime = performance.now();
      
      // Appeler le handler avec les paramÃ¨tres
      const result = await handleSaveNutritionAdvice(this.db, params);
      
      // Calculer le temps d'accÃ¨s pour les logs
      const accessTime = performance.now() - startTime;
      logger.debug(LogCategory.DATABASE, `Database access time for saving nutrition advice: ${accessTime.toFixed(2)}ms`);
      
      return result;
    } catch (error) {
      logger.error(LogCategory.DATABASE, `Error in saveNutritionAdviceViaMCP: ${error instanceof Error ? error.message : String(error)}`);
      return { 
        success: false, 
        error: error instanceof Error ? error.message : String(error)
      };
    }
  }

  /**
   * Met Ã  jour le feedback utilisateur sur un conseil nutritionnel
   * @param params ParamÃ¨tres de mise Ã  jour
   * @returns RÃ©sultat de l'opÃ©ration
   */
  public async updateAdviceFeedbackViaMCP(params: UpdateAdviceFeedbackParams): Promise<UpdateAdviceFeedbackResult> {
    try {
      if (!this.db) throw new Error("Database not initialized");
      
      logger.info(LogCategory.DATABASE, `Updating nutrition advice feedback for advice ${params.adviceId} via MCP Server`);
      
      // Mesurer le temps d'accÃ¨s pour les logs de performance
      const startTime = performance.now();
      
      // Appeler le handler avec les paramÃ¨tres
      const result = await handleUpdateAdviceFeedback(this.db, params);
      
      // Calculer le temps d'accÃ¨s pour les logs
      const accessTime = performance.now() - startTime;
      logger.debug(LogCategory.DATABASE, `Database access time for updating advice feedback: ${accessTime.toFixed(2)}ms`);
      
      return result;
    } catch (error) {
      logger.error(LogCategory.DATABASE, `Error in updateAdviceFeedbackViaMCP: ${error instanceof Error ? error.message : String(error)}`);
      return { 
        success: false, 
        error: error instanceof Error ? error.message : String(error)
      };
    }
  }

  /**
   * RÃ©cupÃ¨re les conseils nutritionnels pour un utilisateur
   * @param params ParamÃ¨tres de recherche
   * @returns Liste des conseils nutritionnels
   */
  public async getNutritionAdviceViaMCP(params: GetNutritionAdviceParams): Promise<GetNutritionAdviceResult> {
    try {
      if (!this.db) throw new Error("Database not initialized");
      
      logger.info(LogCategory.DATABASE, `Getting nutrition advice for user ${params.userId} via MCP Server`);
      
      // Mesurer le temps d'accÃ¨s pour les logs de performance
      const startTime = performance.now();
      
      // Appeler le handler avec les paramÃ¨tres
      const result = await handleGetNutritionAdvice(this.db, params);
      
      // Calculer le temps d'accÃ¨s pour les logs
      const accessTime = performance.now() - startTime;
      logger.debug(LogCategory.DATABASE, `Database access time for getting nutrition advice: ${accessTime.toFixed(2)}ms`);
      
      return result;
    } catch (error) {
      logger.error(LogCategory.DATABASE, `Error in getNutritionAdviceViaMCP: ${error instanceof Error ? error.message : String(error)}`);
      return { 
        success: false, 
        error: error instanceof Error ? error.message : String(error)
      };
    }
  }

  async calculateMealNutritionViaMCP(
    mealId: number,
    quantity: number
  ): Promise<{
    success: boolean;
    error?: string;
    nutrition?: {
      calories: number;
      carbs: number;
      fat: number;
      protein: number;
    };
  }> {
    return await handleCalculateMealNutrition(this.db, { mealId, quantity });
  }

  /**
   * Sauvegarde une suggestion d'ingrÃ©dient dans la base de donnÃ©es
   * @param params ParamÃ¨tres pour la sauvegarde d'une suggestion d'ingrÃ©dient
   * @returns RÃ©sultat de l'opÃ©ration avec l'ID de la suggestion crÃ©Ã©e
   */
  public async saveIngredientSuggestionViaMCP(params: SaveIngredientSuggestionParams): Promise<SaveIngredientSuggestionResult> {
    try {
      if (!this.db) throw new Error("Database not initialized");
      
      logger.info(LogCategory.DATABASE, `Saving ingredient suggestion for "${params.suggestion.name}" via MCP Server`);
      
      const startTime = performance.now();
      const result = await handleSaveIngredientSuggestion(this.db, params);
      const accessTime = performance.now() - startTime;
      
      logger.debug(LogCategory.DATABASE, `Database access time for saving ingredient suggestion: ${accessTime.toFixed(2)}ms`);
      
      return result;
    } catch (error) {
      logger.error(LogCategory.DATABASE, `Error in saveIngredientSuggestionViaMCP: ${error instanceof Error ? error.message : String(error)}`);
      return { 
        success: false, 
        error: error instanceof Error ? error.message : String(error)
      };
    }
  }

  /**
   * RÃ©cupÃ¨re les suggestions d'ingrÃ©dients pour un utilisateur
   * @param params ParamÃ¨tres pour la rÃ©cupÃ©ration des suggestions d'ingrÃ©dients
   * @returns RÃ©sultat de l'opÃ©ration avec la liste des suggestions
   */
  public async getIngredientSuggestionsViaMCP(params: GetIngredientSuggestionsParams): Promise<GetIngredientSuggestionsResult> {
    try {
      if (!this.db) throw new Error("Database not initialized");
      
      logger.info(LogCategory.DATABASE, `Getting ingredient suggestions for user ${params.userId} via MCP Server`);
      
      const startTime = performance.now();
      const result = await handleGetIngredientSuggestions(this.db, params);
      const accessTime = performance.now() - startTime;
      
      logger.debug(LogCategory.DATABASE, `Database access time for getting ingredient suggestions: ${accessTime.toFixed(2)}ms`);
      
      return result;
    } catch (error) {
      logger.error(LogCategory.DATABASE, `Error in getIngredientSuggestionsViaMCP: ${error instanceof Error ? error.message : String(error)}`);
      return { 
        success: false, 
        error: error instanceof Error ? error.message : String(error)
      };
    }
  }

  /**
   * Met Ã  jour une suggestion d'ingrÃ©dient
   * @param params ParamÃ¨tres pour la mise Ã  jour d'une suggestion d'ingrÃ©dient
   * @returns RÃ©sultat de l'opÃ©ration
   */
  public async updateIngredientSuggestionViaMCP(params: UpdateIngredientSuggestionParams): Promise<UpdateIngredientSuggestionResult> {
    try {
      if (!this.db) throw new Error("Database not initialized");
      
      logger.info(LogCategory.DATABASE, `Updating ingredient suggestion ${params.suggestionId} via MCP Server`);
      
      const startTime = performance.now();
      const result = await handleUpdateIngredientSuggestion(this.db, params);
      const accessTime = performance.now() - startTime;
      
      logger.debug(LogCategory.DATABASE, `Database access time for updating ingredient suggestion: ${accessTime.toFixed(2)}ms`);
      
      return result;
    } catch (error) {
      logger.error(LogCategory.DATABASE, `Error in updateIngredientSuggestionViaMCP: ${error instanceof Error ? error.message : String(error)}`);
      return { 
        success: false, 
        error: error instanceof Error ? error.message : String(error)
      };
    }
  }

  /**
   * Supprime une suggestion d'ingrÃ©dient
   * @param params ParamÃ¨tres pour la suppression d'une suggestion d'ingrÃ©dient
   * @returns RÃ©sultat de l'opÃ©ration
   */
  public async deleteIngredientSuggestionViaMCP(params: DeleteIngredientSuggestionParams): Promise<DeleteIngredientSuggestionResult> {
    try {
      if (!this.db) throw new Error("Database not initialized");
      
      logger.info(LogCategory.DATABASE, `Deleting ingredient suggestion ${params.suggestionId} via MCP Server`);
      
      const startTime = performance.now();
      const result = await handleDeleteIngredientSuggestion(this.db, params);
      const accessTime = performance.now() - startTime;
      
      logger.debug(LogCategory.DATABASE, `Database access time for deleting ingredient suggestion: ${accessTime.toFixed(2)}ms`);
      
      return result;
    } catch (error) {
      logger.error(LogCategory.DATABASE, `Error in deleteIngredientSuggestionViaMCP: ${error instanceof Error ? error.message : String(error)}`);
      return { 
        success: false, 
        error: error instanceof Error ? error.message : String(error)
      };
    }
  }

  /**
   * Calcule les valeurs nutritionnelles normalisÃ©es Ã  100g pour un repas
   * @param params ParamÃ¨tres pour le calcul nutritionnel
   * @returns RÃ©sultat avec les valeurs nutritionnelles normalisÃ©es et le facteur d'ajustement
   */
  public async calculateNormalizedNutritionViaMCP(params: CalculateNormalizedNutritionParams): Promise<NormalizedNutritionResult> {
    try {
      if (!this.db) throw new Error("Database not initialized");
      
      logger.info(LogCategory.NUTRITION, `Calculating normalized nutrition for meal ${params.mealId} via MCP Server`);
      
      const startTime = performance.now();
      const result = await handleCalculateNormalizedNutrition(this.db, params);
      const accessTime = performance.now() - startTime;
      
      logger.debug(LogCategory.NUTRITION, `Calculation time for normalized nutrition: ${accessTime.toFixed(2)}ms`);
      
      return result;
    } catch (error) {
      logger.error(LogCategory.NUTRITION, `Error in calculateNormalizedNutritionViaMCP: ${error instanceof Error ? error.message : String(error)}`);
      return { 
        success: false, 
        error: error instanceof Error ? error.message : String(error)
      };
    }
  }

  /**
   * Obtient le poids total d'un repas basÃ© sur ses ingrÃ©dients
   * @param params ParamÃ¨tres pour la requÃªte
   * @returns RÃ©sultat avec le poids total du repas
   */
  public async getMealWeightViaMCP(params: GetMealWeightParams): Promise<GetMealWeightResult> {
    try {
      if (!this.db) throw new Error("Database not initialized");
      
      logger.info(LogCategory.NUTRITION, `Getting meal weight for meal ${params.mealId} via MCP Server`);
      
      const startTime = performance.now();
      const result = await handleGetMealWeight(this.db, params);
      const accessTime = performance.now() - startTime;
      
      logger.debug(LogCategory.NUTRITION, `Calculation time for meal weight: ${accessTime.toFixed(2)}ms`);
      
      return result;
    } catch (error) {
      logger.error(LogCategory.NUTRITION, `Error in getMealWeightViaMCP: ${error instanceof Error ? error.message : String(error)}`);
      return { 
        success: false, 
        error: error instanceof Error ? error.message : String(error)
      };
    }
  }

  /**
   * Calcule la rÃ©partition des macronutriments d'un repas
   * @param params ParamÃ¨tres pour le calcul
   * @returns RÃ©sultat avec la rÃ©partition des macronutriments
   */
  public async getMacroBreakdownViaMCP(params: GetMacroBreakdownParams): Promise<GetMacroBreakdownResult> {
    try {
      if (!this.db) throw new Error("Database not initialized");
      
      logger.info(LogCategory.NUTRITION, `Getting macro breakdown for meal ${params.mealId} via MCP Server`);
      
      const startTime = performance.now();
      const result = await handleGetMacroBreakdown(this.db, params);
      const accessTime = performance.now() - startTime;
      
      logger.debug(LogCategory.NUTRITION, `Calculation time for macro breakdown: ${accessTime.toFixed(2)}ms`);
      
      return result;
    } catch (error) {
      logger.error(LogCategory.NUTRITION, `Error in getMacroBreakdownViaMCP: ${error instanceof Error ? error.message : String(error)}`);
      return { 
        success: false, 
        error: error instanceof Error ? error.message : String(error) 
      };
    }
  }

  /**
   * Calcule les valeurs nutritionnelles d'un plan journalier
   * @param params ParamÃ¨tres contenant l'ID du plan journalier et l'ID de l'utilisateur
   * @returns RÃ©sultat avec les valeurs nutritionnelles calculÃ©es
   */
  public async getDailyPlanNutritionViaMCP(params: GetDailyPlanNutritionParams): Promise<GetDailyPlanNutritionResult> {
    try {
      if (!this.db) throw new Error("Database not initialized");
      
      logger.info(LogCategory.NUTRITION, `Getting nutrition for daily plan ${params.dailyPlanId} for user ${params.userId} via MCP Server`);
      
      const startTime = performance.now();
      const result = await handleGetDailyPlanNutrition(this.db, params);
      const accessTime = performance.now() - startTime;
      
      logger.debug(LogCategory.NUTRITION, `Calculation time for daily plan nutrition: ${accessTime.toFixed(2)}ms`);
      
      return result;
    } catch (error) {
      logger.error(LogCategory.NUTRITION, `Error in getDailyPlanNutritionViaMCP: ${error instanceof Error ? error.message : String(error)}`);
      return { 
        success: false, 
        error: error instanceof Error ? error.message : String(error) 
      };
    }
  }

  /**
   * Expose the underlying Drizzle DB instance (read/write)
   * Ã utiliser uniquement dans les services core via l'instance singleton.
   */
  public getDb() {
    return this.db;
  }

  /**
   * ---------- Scan History ----------
   */
  public async addScanHistoryViaMCP(params: AddScanHistoryParams) {
    return handleAddScanHistory(this.db, params);
  }

  public async getScanHistoryViaMCP(params: GetScanHistoryParams) {
    return handleGetScanHistory(this.db, params);
  }

  public async clearScanHistoryViaMCP(userId: number) {
    try {
      const result = await this.db.delete(scanHistory).where(eq(scanHistory.userId, userId));
      return { success: true };
    } catch (error) {
      logger.error(LogCategory.DATABASE, 'Failed to clear scan history', error);
      return { success: false, error: error instanceof Error ? error.message : 'Unknown error' };
    }
  }
}

export default SQLiteMCPServer.getInstance();
