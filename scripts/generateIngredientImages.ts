import fs from 'fs';
import path from 'path';
import glob from 'glob';

// Directory where seed files are located
const seedDir = path.resolve(__dirname, '..', 'db');

const mappingFilePath = path.resolve(seedDir, 'ingredientImages.ts');

// Regex to capture image string value
const imageRegex = /image:\s*['"]([^'"]+)['"]/g;

// Collect unique image paths
const imageSet = new Set<string>();

// 1) Parcourir les fichiers seed (.ts) pour extraire les chemins déclarés dans la propriété `image`
const files = glob
  .sync(path.join(seedDir, '**/*.ts'))
  .filter((f) => !f.endsWith('ingredientImages.ts'));

files.forEach((file) => {
  const content = fs.readFileSync(file, 'utf-8');
  let match: RegExpExecArray | null;
  while ((match = imageRegex.exec(content))) {
    const imgPath = match[1];
    if (imgPath && imgPath.startsWith('../assets/images/seed')) {
      imageSet.add(imgPath);
    }
  }
});

// 2) Fallback : parcourir directement le dossier assets pour ne pas manquer une image renvoyée (et couvrir les cas où les seeds n'ont pas encore l'attribut `image` rempli)
const assetsDir = path.resolve(__dirname, '..', 'assets', 'images', 'seed');
const assetFiles = glob.sync('**/*.jpg', { cwd: assetsDir, nodir: true });
assetFiles.forEach((relPath) => {
  // Normaliser les séparateurs pour React-Native/Metro
  const normalized = relPath.split(path.sep).join('/');
  imageSet.add(`../assets/images/seed/${normalized}`);
});

// Generate mapping file content
const header = `// Auto-generated by scripts/generateIngredientImages.ts\n// Do not edit manually – run \"npm run generate:ingredient-images\"\n\nexport const ingredientImages: Record<string, number> = {\n`;

const entries = Array.from(imageSet)
  .sort()
  .map((p) => {
    const escaped = p.replace(/'/g, "\\'");
    return `  '${escaped}': require('${escaped}'),`;
  })
  .join('\n');

const footer = '\n};\n';

fs.writeFileSync(mappingFilePath, header + entries + footer, 'utf-8');
console.log(`ingredientImages.ts updated with ${imageSet.size} entries.`);
