# Checklist d'Audit de Code pour Lift-Eat-Mobile

Cette checklist exhaustive permet d'√©valuer tous les flux possibles au niveau du code avant de passer √† une revue au niveau UI. Elle est organis√©e par domaine fonctionnel et couvre tous les aspects critiques de l'application.

## 1. üîê Flux d'Authentification et Gestion Utilisateur

- [x] **Enregistrement utilisateur**
  - [x] V√©rifier la validation des entr√©es (email, mot de passe)
    - ‚úÖ Validation Zod dans `register-schema.validation.ts` et `password-schema.validation.ts`
    - ‚úÖ Email: transformation (trim, lowercase) et v√©rification du format
    - ‚úÖ Mot de passe: min 6 caract√®res, majuscule, minuscule, chiffre
    - ‚úÖ Utilisation de `react-hook-form` avec `zodResolver` pour valider le formulaire
  - [x] Confirmer le flux de cr√©ation utilisateur via MCP server (`createUserViaMCP`)
    - ‚úÖ M√©thode `createUserViaMCP` impl√©ment√©e dans `SQLiteMCPServer`
    - ‚úÖ Handler `handleCreateUser` g√®re l'insertion en base de donn√©es
    - ‚úÖ Gestion des erreurs et logging complets
    - ‚ö†Ô∏è Interface utilisateur utilise actuellement un mock plut√¥t que l'appel MCP r√©el
  - [x] V√©rifier la gestion des erreurs (email existant, validation √©chou√©e)
    - ‚úÖ Retours d'erreurs structur√©s par le handler
    - ‚úÖ Affichage des erreurs de validation dans l'UI avec `FormControlError`
    - ‚úÖ Toasts de notification pour les erreurs d'API avec `MultiPurposeToast`
    - ‚úÖ Gestion des cas d'erreur c√¥t√© serveur
  - [x] Valider le stockage des tokens JWT ou m√©canismes d'authentification
    - ‚ùì Potentielle utilisation ant√©rieure de Clerk (code comment√©)
    - ‚ö†Ô∏è Besoin d'examiner le stockage et la gestion des tokens

- [x] **Connexion utilisateur**
  - [x] V√©rifier le processus d'authentification (appels API, validation locale)
    - ‚úÖ Utilisation de `findOrCreateUserViaMCP` dans le flux de connexion
    - ‚úÖ Validation des champs email/mot de passe avec sch√©mas Zod (m√™me sch√©ma que l'inscription)
    - ‚úÖ Gestion des erreurs d'authentification appropri√©e
    - ‚ö†Ô∏è Absence de v√©rification du mot de passe c√¥t√© serveur (utilisation d'email uniquement)
  - [x] Confirmer la mise √† jour du state global utilisateur via SessionStore
    - ‚úÖ Utilisation de Zustand avec `useSessionStore` pour la gestion d'√©tat global
    - ‚úÖ Persistance via AsyncStorage pour maintenir la session entre les red√©marrages
    - ‚úÖ M√©thode `setUser` appel√©e apr√®s connexion r√©ussie
    - ‚úÖ Redirection automatique vers `/analytics` apr√®s connexion
  - [x] V√©rifier les pr√©requis d'authentification pour les routes prot√©g√©es
    - ‚úÖ Structure d'application nested avec groupes de routes `(auth)` et `(tabs)`
    - ‚ö†Ô∏è Pas de v√©rification visible de session dans le layout parent des routes prot√©g√©es
  - [ ] Valider le m√©canisme de rafra√Æchissement des tokens
    - ‚ùì Structure pour tokens JWT pr√©sente dans sessionStore mais non utilis√©e
    - ‚ö†Ô∏è Pas de m√©canisme visible pour rafra√Æchir les tokens expir√©s

- [x] **Gestion du profil utilisateur**
  - [x] V√©rifier les appels √† `updateUserPreferencesViaMCP`
    - ‚úÖ Impl√©ment√© dans `UserGenderActivityForm` pour les pr√©f√©rences utilisateur
    - ‚úÖ Validation des champs avec sch√©mas Zod bien impl√©ment√©e
    - ‚úÖ V√©rification que l'utilisateur ne modifie que son propre profil
    - ‚úÖ Retours d'erreurs clairs en cas d'√©chec de mise √† jour
  - [x] Confirmer la mise √† jour des donn√©es utilisateur (poids, taille, activit√© physique)
    - ‚úÖ Page de pr√©f√©rences d√©di√©e pour modifier l'√¢ge, le genre et l'activit√© physique
    - ‚úÖ Mise √† jour correctement valid√©e avant soumission 
    - ‚úÖ Formulaires sp√©cialis√©s (GenderFormInput, PhysicalActivityFormInput)
    - ‚ö†Ô∏è Pas de validation c√¥t√© serveur des valeurs autoris√©es
  - [x] Valider les m√©canismes de changement de mot de passe
    - ‚ùì `ForgetPasswordModal` pr√©sent dans l'application
    - ‚ö†Ô∏è Pas de fonctionnalit√© visible pour changer le mot de passe dans le profil
  - [x] V√©rifier la gestion des images de profil
    - ‚úÖ `UserProfileForm` impl√©mente la s√©lection d'image (cam√©ra ou galerie)
    - ‚úÖ Images stock√©es comme cha√Ænes dans la base de donn√©es (probablement en base64)
    - ‚ö†Ô∏è Pas de compression ou redimensionnement visible des images

- [x] **D√©connexion**
  - [x] Confirmer l'effacement correct des donn√©es de session
    - ‚ö†Ô∏è Deux m√©canismes ind√©pendants qui ne sont pas coordonn√©s :
      - `clearSession()` dans `sessionStore.ts` qui nettoie correctement les donn√©es de session
      - `logout()` dans `UserContextProvider.tsx` qui ne r√©initialise que l'utilisateur courant
    - ‚ö†Ô∏è `logout()` n'appelle pas `clearSession()`, risque de donn√©es persistantes
  - [x] V√©rifier la redirection vers l'√©cran de login
    - ‚ùå Pas de redirection automatique vers l'√©cran de login impl√©ment√©e
    - ‚ö†Ô∏è Fonction `logout()` n'utilise pas le router pour rediriger
  - [x] Valider l'invalidation des tokens eventuels
    - ‚ö†Ô∏è `token` et `tokenExpire` sont remis √† null dans `clearSession()` 
    - ‚ùå Pas d'invalidation c√¥t√© serveur des tokens (appel API pour blacklister les tokens)
    - ‚ùå Aucun bouton ou √©cran de d√©connexion visible dans les interfaces parcourues

## 2. üç¥ Flux de Gestion des Repas

- [x] **Cr√©ation de repas**
  - [x] V√©rifier les appels √† `createMealViaMCP` et `createNewMealViaMCP`
    - ‚úÖ Impl√©ment√©s dans `SQLiteMCPServer` via les handlers MCP correspondants
    - ‚úÖ `MealForm` utilise `createNewMealViaMCP` pour la cr√©ation de repas
    - ‚úÖ Transactions utilis√©es pour assurer l'int√©grit√© des donn√©es (repas + ingr√©dients)
    - ‚úÖ Logging d√©taill√© des op√©rations et des erreurs potentielles
  - [x] Confirmer la validation des champs obligatoires (nom, calories, etc.)
    - ‚úÖ Validation c√¥t√© client avec sch√©ma Zod (`mealSchema`)
    - ‚úÖ Formulaire utilise `react-hook-form` avec `zodResolver` pour appliquer les validations
    - ‚úÖ Messages d'erreur clairs pour les champs invalides
    - ‚úÖ Types √©num√©r√©s pour les valeurs pr√©d√©finies (MealTypeEnum, CuisineTypeEnum, etc.)
  - [x] Valider le flux d'ajout d'ingr√©dients au repas
    - ‚úÖ `IngredientsDrawer` permet la s√©lection des ingr√©dients
    - ‚úÖ Store global (`useIngredientStore`) pour g√©rer les ingr√©dients s√©lectionn√©s
    - ‚úÖ Interface visuelle pour afficher les ingr√©dients s√©lectionn√©s (`IngredientCard`)
    - ‚úÖ Stockage dans la table de jointure `mealIngredients` via la transaction
  - [x] V√©rifier le calcul des macronutriments (somme des ingr√©dients)
    - ‚úÖ Calcul automatique des totaux via `totalMacros` dans le state global
    - ‚úÖ Affichage des macros dans `MacrosInfoCard`
    - ‚úÖ Synchronisation du poids total du repas avec le poids des ingr√©dients
    - ‚úÖ Persistence des macros calcul√©s dans la base de donn√©es

- [x] **Modification de repas**
  - [x] V√©rifier les appels √† `updateMealViaMCP`
    - ‚úÖ M√©thode impl√©ment√©e dans `SQLiteMCPServer` avec appel au handler `handleUpdateMeal`
    - ‚úÖ M√™me composant `MealForm` utilis√© pour la cr√©ation et la modification (via prop `operation`)
    - ‚úÖ Transaction utilis√©e pour la mise √† jour atomique du repas et de ses ingr√©dients
    - ‚úÖ Gestion correcte des param√®tres et validation des entr√©es
  - [x] Confirmer que seul le cr√©ateur peut modifier le repas
    - ‚úÖ V√©rification c√¥t√© client dans `MealForm.mutationFn` qui valide la propri√©t√© du repas
    - ‚úÖ V√©rification suppl√©mentaire c√¥t√© serveur dans `handleUpdateMeal`
    - ‚úÖ Clause SQL avec `and(eq(meals.id, mealId), eq(meals.creatorId, userId))` qui garantit la s√©curit√©
    - ‚úÖ Messages d'erreur clairs si l'utilisateur tente de modifier un repas qui ne lui appartient pas
  - [x] Valider la mise √† jour des relations repas-ingr√©dients
    - ‚úÖ Approche "delete and recreate" pour les ingr√©dients : suppression des liens existants puis cr√©ation des nouveaux
    - ‚úÖ Transaction qui garantit l'atomicit√© de l'op√©ration (tout ou rien)
    - ‚úÖ M√™me interface utilisateur que la cr√©ation pour la s√©lection et gestion des ingr√©dients
    - ‚úÖ Validation des ingr√©dients s√©lectionn√©s avant soumission
  - [x] V√©rifier l'invalidation des caches apr√®s modification
    - ‚úÖ Appel √† `invalidateCache(queryClient, DataType.MEAL)` dans `MealForm.mutationFn`
    - ‚úÖ Option `invalidateRelated: true` qui permet d'invalider aussi les caches d√©pendants
    - ‚úÖ Gestion de cas sp√©cifique avec l'ID du repas modifi√©
    - ‚úÖ Logging des invalidations de cache pour le d√©bogage

- [x] **Suppression de repas**
  - [x] V√©rifier les appels √† `deleteMealViaMCP`
    - ‚úÖ Impl√©ment√© dans `SQLiteMCPServer` avec appel au handler `handleDeleteMeal`
    - ‚úÖ Utilis√© dans les composants `MealCard` et `MealDetailsScreen`
    - ‚úÖ V√©rifications compl√®tes des param√®tres et gestion d'erreurs
    - ‚úÖ Mesure des performances avec `performance.now()` pour optimiser l'acc√®s √† la base de donn√©es
  - [x] Valider que seul le cr√©ateur peut supprimer son repas
    - ‚úÖ V√©rification c√¥t√© client dans `MealCard.mutationFn` qui compare `item.creatorId` avec `userId`
    - ‚úÖ V√©rification c√¥t√© serveur dans `handleDeleteMeal` avec clause SQL appropri√©e
    - ‚úÖ Messages d'erreur pr√©cis en cas de tentative non autoris√©e
    - ‚úÖ Logging des tentatives de suppression non autoris√©es
  - [x] Confirmer la suppression des relations avec les ingr√©dients
    - ‚úÖ Transaction utilis√©e pour assurer l'int√©grit√© r√©f√©rentielle
    - ‚úÖ Suppression des liens dans la table `mealIngredients` avant la suppression du repas
    - ‚úÖ V√©rification et gestion des r√©f√©rences dans `dailyPlanMeals` (plans contenant ce repas)
    - ‚úÖ Op√©rations s√©quenc√©es logiquement pour √©viter les erreurs d'int√©grit√©
  - [x] V√©rifier l'invalidation des caches apr√®s suppression
    - ‚úÖ Appel √† `invalidateCache(queryClient, DataType.MEAL)` dans `MealCard.onSuccess`
    - ‚úÖ Option `invalidateRelated: true` pour mettre √† jour les listes de repas
    - ‚úÖ Notification √† l'utilisateur via `MultiPurposeToast` pour confirmer la suppression
    - ‚úÖ Fermeture automatique de la modale de confirmation apr√®s suppression r√©ussie

- [x] **Recherche et filtrage de repas**
  - [x] V√©rifier les appels √† `getMealsListViaMCP` avec filtres
    - ‚úÖ Impl√©ment√© dans `SQLiteMCPServer` avec param√®tres pour filtrer par cuisine, type et nom
    - ‚úÖ Handler `handleGetMealsList` qui construit dynamiquement la requ√™te SQL en fonction des filtres
    - ‚úÖ Support de la recherche par nom avec l'op√©rateur `LIKE` et des wildcards (`%search%`)
    - ‚úÖ Limitation du nombre de r√©sultats pour optimiser les performances
  - [x] Valider l'interface utilisateur pour les filtres (type, cuisine, nom)
    - ‚úÖ Composants `CuisineTypeBox` et `MealTypeBox` pour s√©lectionner les filtres
    - ‚úÖ Champ de recherche avec `InputField` pour la recherche par texte
    - ‚úÖ M√©canismes `handleCuisineSelect` et `handleMealTypeSelect` pour g√©rer les s√©lections
    - ‚úÖ R√©initialisation appropri√©e des autres filtres lors de l'application d'un filtre
  - [x] Confirmer le fonctionnement de la recherche par texte
    - ‚úÖ `handleMealNameSearch` pour actualiser les r√©sultats pendant la saisie
    - ‚úÖ Transmission correcte du terme de recherche √† l'API MCP
    - ‚úÖ Nettoyage des termes de recherche (trim, toLowerCase) pour une correspondance optimale
    - ‚úÖ Interface r√©active qui met √† jour les r√©sultats imm√©diatement
  - [x] V√©rifier la mise √† jour des r√©sultats apr√®s application des filtres
    - ‚úÖ Utilisation de `useQuery` de React Query avec cl√©s d√©pendantes des filtres
    - ‚úÖ Appel √† `refetch()` apr√®s chaque changement de filtre
    - ‚úÖ Affichage d'√©tats de chargement via `QueryStateHandler`
    - ‚úÖ Validation rigoureuse des donn√©es re√ßues pour √©viter les erreurs d'affichage

## 3. üìà Flux de Gestion des Plans Nutritionnels

- [x] **Cr√©ation de plan**
  - [x] V√©rifier les appels √† `createPlanViaMCP`
    - ‚úÖ M√©thode `addPlanViaMCP` impl√©ment√©e dans SQLiteMCPServer avec appel √† `handleCreatePlan`
    - ‚úÖ Support pour les plans g√©n√©r√©s par IA via l'interface `IaPlanType`
    - ‚úÖ Migration compl√®te des handlers vers l'architecture MCP
  - [x] Confirmer le calcul des objectifs nutritionnels (calories, macros)
    - ‚úÖ Calcul d√©taill√© des macronutriments dans `handleCreatePlan`
    - ‚úÖ Utilisation de valeurs par d√©faut si non sp√©cifi√©es (carbs: 45%, protein: 30%, fat: 25%)
    - ‚úÖ Support du Goal (WEIGHT_LOSS, MUSCLE_GAIN, MAINTAIN) pour orienter les calculs
  - [x] Valider la cr√©ation des plans journaliers associ√©s
    - ‚úÖ Cr√©ation automatique via `handleCreateDailyPlans` en transaction
    - ‚úÖ G√©n√©ration des plans pour chaque jour de la semaine pour toute la dur√©e
    - ‚úÖ Support de `durationWeeks` pour d√©finir la longueur du plan (d√©faut: 12 semaines)
  - [x] V√©rifier la d√©finition du plan comme courant si n√©cessaire
    - ‚úÖ M√©thode `handleSetCurrentPlan` pour d√©finir un plan comme actuel
    - ‚úÖ D√©sactivation automatique des autres plans courants de l'utilisateur
    - ‚úÖ V√©rification que le plan appartient bien √† l'utilisateur

- [x] **Modification de plan**
  - [x] V√©rifier les appels √† `updatePlanViaMCP`
    - ‚úÖ Handler `handleUpdatePlan` compl√®tement impl√©ment√© dans `plan-handlers.ts`
    - ‚úÖ Interface d'√©dition de plan impl√©ment√©e dans `(root)/(tabs)/plans/my-plans/edit/[id].tsx`
    - ‚úÖ Formulaire complet avec validation des champs via Zod et react-hook-form
    - ‚úÖ Handler MCP correctement utilis√© avec validation et transaction
  - [x] Confirmer que seul le propri√©taire peut modifier le plan
    - ‚úÖ V√©rification de propri√©t√© dans `handleUpdatePlan` via `eq(plan.userId, userId)`
    - ‚úÖ Message d'erreur explicite si le plan n'appartient pas √† l'utilisateur
    - ‚úÖ Logging d√©taill√© des tentatives d'acc√®s non autoris√©es
    - ‚úÖ V√©rification dans `handleUpdatePlan` avec clause SQL `and(eq(plan.id, planId), eq(plan.userId, userId))`
    - ‚úÖ Messages d'erreur explicites si l'utilisateur tente de modifier un plan qui ne lui appartient pas
    - ‚úÖ V√©rifications de s√©curit√© coh√©rentes √† travers le code
    - ‚úÖ Logging de s√©curit√© pour les tentatives non autoris√©es
  - [x] Valider la mise √† jour des plans journaliers associ√©s
    - ‚úÖ Mise √† jour automatique des plans journaliers lorsque le plan principal est modifi√©
    - ‚úÖ Propagation des valeurs nutritionnelles (calories, carbs, protein, fat) aux plans journaliers
    - ‚úÖ Impl√©mentation dans une transaction pour assurer la coh√©rence des donn√©es
    - ‚úÖ Fonctionnalit√© `updateMealQuantityInPlanViaMCP` disponible pour modifier des repas sp√©cifiques
    - ‚úÖ Architecture en place pour supporter ces modifications
  - [x] V√©rifier l'invalidation des caches apr√®s modification
    - ‚úÖ Appel √† `invalidateCache` avec `DataType.PLAN` et option `invalidateRelated: true`
    - ‚úÖ Invalidation coh√©rente dans toute l'application
    - ‚úÖ Les donn√©es connexes sont √©galement invalid√©es
    - ‚úÖ Logging d√©taill√© des invalidations de cache

- [x] **Suppression de plan**
  - [x] V√©rifier les appels √† `deletePlanViaMCP`
    - ‚úÖ Impl√©ment√© dans `SQLiteMCPServer` avec appel au handler `handleDeletePlan`
    - ‚úÖ Utilis√© dans `PlanCard` avec confirmation de l'utilisateur avant suppression
    - ‚úÖ V√©rifications de s√©curit√© et validations appropri√©es
    - ‚úÖ Gestion des erreurs et notifications √† l'utilisateur
  - [x] Valider la suppression des plans journaliers associ√©s
    - ‚úÖ Transaction dans `handleDeletePlan` qui supprime d'abord les plans journaliers associ√©s
    - ‚úÖ R√©cup√©ration de tous les plans journaliers li√©s via `select({ id: dailyPlan.id }).from(dailyPlan).where(eq(dailyPlan.planId, planId))`
    - ‚úÖ Suppression via `tx.delete(dailyPlan).where(eq(dailyPlan.planId, planId))`
    - ‚úÖ Logging d√©taill√© du processus de suppression
  - [x] Confirmer la suppression des associations plan-repas
    - ‚úÖ Suppression pr√©alable des associations avec `tx.delete(dailyPlanMeals).where(inArray(dailyPlanMeals.dailyPlanId, dailyPlanIds))`
    - ‚úÖ Utilisation de `inArray` pour une suppression efficace de toutes les associations
    - ‚úÖ Op√©rations dans un ordre logique pour maintenir l'int√©grit√© r√©f√©rentielle
    - ‚úÖ V√©rification du statut de plan courant avant suppression
  - [x] V√©rifier l'invalidation des caches apr√®s suppression
    - ‚úÖ Appel √† `invalidateCache(queryClient, DataType.PLAN)` dans `PlanCard.onSuccess`
    - ‚úÖ Option `invalidateRelated: true` pour mettre √† jour les listes et les donn√©es connexes
    - ‚úÖ Notification √† l'utilisateur via `MultiPurposeToast` pour confirmer la suppression
    - ‚úÖ Fermeture de la modale de confirmation apr√®s suppression r√©ussie

- [x] **Ajout de repas √† un plan**
  - [x] V√©rifier les appels √† `addMealToDailyPlanViaMCP`
    - ‚úÖ Impl√©ment√© dans `SQLiteMCPServer` avec appel au handler `handleAddMealToDailyPlan`
    - ‚úÖ Utilis√© dans `PlanDetailsScreen.handleAddMealToPlan` qui sert d'interface avec le composant `MealsDrawer`
    - ‚úÖ V√©rification d'authentification et de propri√©t√© avant l'ajout
    - ‚úÖ Gestion des transactions et mise √† jour des totaux nutritionnels du plan journalier
  - [x] Valider l'interface de s√©lection des repas √† ajouter
    - ‚úÖ Composant `MealsDrawer` qui permet la recherche et le filtrage des repas disponibles
    - ‚úÖ Possibilit√© de filtrer par type de cuisine et type de repas
    - ‚úÖ Interface d'ajout multiple (plusieurs repas en m√™me temps)
    - ‚úÖ Interface bien structur√©e avec √©tats de chargement et gestion des erreurs
  - [x] Valider les contr√¥les de compatibilit√©
    - ‚úÖ V√©rification que le repas existe via `meal = await db.select().from(meals).where(eq(meals.id, mealId)).limit(1)`
    - ‚úÖ V√©rification que le plan journalier existe
    - ‚úÖ Gestion des doublons avec message sp√©cifique `already in this daily plan`
    - ‚úÖ Signalement appropri√© √† l'utilisateur lors de conditions sp√©ciales
  - [x] V√©rifier la gestion des quantit√©s de repas
    - ‚úÖ Interface avec contr√¥les +/- pour ajuster la quantit√© (grammes)
    - ‚úÖ Calcul dynamique des valeurs nutritionnelles en fonction de la quantit√© s√©lectionn√©e
    - ‚úÖ Formule `quantityRatio = quantity / 100` appliqu√©e aux macronutriments
    - ‚úÖ Mise √† jour du plan journalier avec les nouvelles valeurs nutritionnelles totales

- [x] **Suivi de progression de plan**
  - [x] V√©rifier les appels √† `getDailyProgressByPlanViaMCP`
    - ‚úÖ Impl√©ment√© dans `SQLiteMCPServer` avec appel au handler `handleGetDailyProgressByPlan`
    - ‚úÖ V√©rification de s√©curit√© dans le handler pour s'assurer que l'utilisateur est propri√©taire du plan
    - ‚úÖ Requ√™te SQL bien form√©e pour r√©cup√©rer toutes les progressions quotidiennes d'un plan
    - ‚úÖ Utilis√© dans `ProgressCalendarTab` pour afficher la progression dans un calendrier
  - [x] Confirmer l'affichage des progr√®s sous forme de calendrier
    - ‚úÖ Utilisation de marqueurs de calendrier avec code couleur bas√© sur le pourcentage de compl√©tion
    - ‚úÖ Rouge (<30%), Jaune (30-70%), Vert (>70%) pour indiquer le niveau de progression
    - ‚úÖ Conversion des jours de la semaine en dates pour le calendrier
    - ‚úÖ Affichage des plans pr√©vus et des progressions r√©elles sur le m√™me calendrier
  - [x] Valider l'interface entre plans et progressions quotidiennes
    - ‚úÖ Int√©gration des donn√©es du plan et des progressions pour une vue compl√®te
    - ‚úÖ Utilisation de `React.useMemo` pour optimiser le calcul des marqueurs de calendrier
    - ‚úÖ Logging d√©taill√© pour faciliter le d√©bogage
    - ‚úÖ Gestion appropri√©e des cas o√π il n'y a pas de progression ou de plan

## 4. üç£ Flux de Gestion des Ingr√©dients

- [x] **Cr√©ation d'ingr√©dients**
  - [x] V√©rifier les appels √† `addIngredientViaMCP`
    - ‚úÖ Handler `handleAddIngredient` impl√©ment√© dans `ingredient-handlers.ts`
    - ‚úÖ Interface `AddIngredientParams` et `AddIngredientResult` d√©finies
    - ‚úÖ M√©thode correctement expos√©e dans `SQLiteMCPServer`
    - ‚úÖ Logging d√©taill√© et mesure de performance impl√©ment√©s
  - [x] Confirmer la validation des donn√©es nutritionnelles
    - ‚úÖ V√©rification des valeurs nutritionnelles dans le handler
    - ‚úÖ D√©finition de valeurs par d√©faut (0) pour les champs manquants
    - ‚úÖ Structure de donn√©es compl√®te avec calories, carbs, protein, fat
  - [x] Valider la d√©duplication des ingr√©dients similaires
    - ‚úÖ V√©rification des ingr√©dients existants par nom
    - ‚úÖ Retour d'un r√©sultat avec flag `alreadyExists: true` si trouv√©
    - ‚úÖ Logging d√©taill√© pour la tra√ßabilit√© des duplications
  - [x] V√©rifier la gestion des unit√©s de mesure
    - ‚úÖ Sauvegarde de l'unit√© fournie dans `ingredientData.unit`
    - ‚ö†Ô∏è Pas de validation explicite des unit√©s contre l'√©num `MealUnitEnum`
    - üîÑ √Ä impl√©menter: validation des unit√©s dans le handler

- [x] **Recherche d'ingr√©dients**
  - [x] V√©rifier les appels √† `getIngredientsListViaMCP`
    - ‚úÖ Handler `handleGetIngredientsList` impl√©ment√© dans `ingredient-handlers.ts`
    - ‚úÖ Interface `GetIngredientsListParams` et `GetIngredientsListResult` d√©finies
    - ‚úÖ M√©thode expos√©e avec param√®tres de recherche et de limite
    - ‚úÖ Recherche insensible √† la casse impl√©ment√©e avec `like()`
  - [x] Confirmer la performance de la recherche
    - ‚úÖ Limitation du nombre de r√©sultats par d√©faut (50)
    - ‚úÖ Suivi du temps de r√©ponse avec `startPerformanceLog`/`endPerformanceLog`
    - ‚úÖ Logging d√©taill√© des param√®tres de recherche et des r√©sultats

- [x] **Mise √† jour d'ingr√©dients**
  - [x] V√©rifier les appels √† `updateIngredientViaMCP`
    - ‚úÖ Handler `handleUpdateIngredient` impl√©ment√© correctement
    - ‚úÖ V√©rification de l'existence de l'ingr√©dient avant mise √† jour
    - ‚úÖ Interface `UpdateIngredientParams` et `UpdateIngredientResult` d√©finies
    - ‚úÖ M√©thode expos√©e dans `SQLiteMCPServer`
  - [x] Confirmer la mise √† jour du timestamp
    - ‚úÖ Mise √† jour automatique du champ `updatedAt` √† chaque modification

- [x] **Suppression d'ingr√©dients**
  - [x] V√©rifier les appels √† `deleteIngredientViaMCP`
    - ‚úÖ Handler `handleDeleteIngredient` impl√©ment√© correctement
    - ‚úÖ V√©rification de l'existence de l'ingr√©dient avant suppression
    - ‚úÖ Interface `DeleteIngredientParams` et `DeleteIngredientResult` d√©finies
    - ‚úÖ M√©thode expos√©e dans `SQLiteMCPServer`
  - [x] Valider la gestion des r√©f√©rences (int√©grit√© r√©f√©rentielle)
    - ‚úÖ V√©rification compl√®te des r√©f√©rences dans `mealIngredients` avant suppression
    - ‚úÖ Message d'erreur d√©taill√© si l'ingr√©dient est utilis√© dans des repas
    - ‚úÖ Liste des IDs de repas utilisant l'ingr√©dient fournie en cas d'erreur

- [x] **Invalidation du cache**
  - [x] Confirmer l'impl√©mentation pour toutes les op√©rations
    - ‚úÖ Invalidation du cache apr√®s ajout d'un ingr√©dient
    - ‚úÖ Invalidation du cache apr√®s mise √† jour d'un ingr√©dient
    - ‚úÖ Invalidation du cache apr√®s suppression d'un ingr√©dient
  - [x] V√©rifier la cascade d'invalidation
    - ‚úÖ Relation `INGREDIENT` ‚ûù `INGREDIENTS_LIST` d√©finie dans `RELATED_TYPES`
    - ‚úÖ Option `invalidateRelated: true` utilis√©e appropri√©ment

- [x] **Am√©liorations futures identifi√©es**
  - [ ] Impl√©menter la validation des unit√©s contre l'√©num `MealUnitEnum`
  - [ ] Ajouter une v√©rification compl√®te des r√©f√©rences avant suppression
  - [ ] Impl√©menter la pagination pour les listes d'ingr√©dients volumineuses
  - [ ] Ajouter des options de tri (par nom, valeurs nutritionnelles)

- [x] **Int√©gration dans l'interface utilisateur (existante)**
  - [x] V√©rifier la s√©lection d'ingr√©dients dans les formulaires
    - ‚úÖ S√©lection d'ingr√©dients impl√©ment√©e dans `MealForm.tsx` 
    - ‚úÖ Composant `IngredientPickerDrawer` pour la s√©lection d'ingr√©dients existants
    - ‚úÖ Interface de recherche avec filtrage par nom impl√©ment√©e
    - ‚úÖ Utilisation de `getIngredientsListViaMCP` pour r√©cup√©rer les ingr√©dients
  - [x] Confirmer la validation et l'affichage
    - ‚úÖ Ingr√©dients affich√©s avec valeurs nutritionnelles dans `IngredientCard`
    - ‚úÖ Gestion des portions et quantit√©s impl√©ment√©e
    - ‚úÖ Calcul des valeurs nutritionnelles totales impl√©ment√© dans le formulaire

- [x] **Am√©liorations pour la consultation des ingr√©dients standards**
  - [ ] **Am√©liorations des composants existants**
    - ‚úÖ Backend MCP compl√®tement impl√©ment√© et pr√™t √† l'usage
    - ‚úÖ M√©thode `getIngredientsListViaMCP` pour r√©cup√©rer la liste des ingr√©dients
    - ‚úÖ Syst√®me d'invalidation de cache configur√© pour une exp√©rience r√©active
    - ‚úÖ Composant `IngredientPickerDrawer` d√©j√† fonctionnel pour la s√©lection d'ingr√©dients
    - ‚ÑπÔ∏è Note: Les ingr√©dients standards sont pr√©d√©finis et charg√©s au d√©marrage de l'application
  - [ ] **Fonctionnalit√©s √† ajouter aux composants existants**
    - ‚ùå Ajouter un filtre nutritionnel avanc√© dans `IngredientsDrawer`
      - Impl√©menter un composant `NutritionFilters` avec sliders pour filtrer par calories, prot√©ines, etc.
      - Int√©grer avec le composant `Collapsible` de GlueStack UI pour une interface extensible
      - Modifier la logique de recherche dans `fetchIngredients` pour appliquer les filtres additionnels
    - ‚ùå Impl√©menter un syst√®me de favoris avec stockage local
      - Cr√©er un hook personnalis√© `useFavoriteIngredients` utilisant AsyncStorage
      - Ajouter une option de favoris dans les cartes d'ingr√©dients avec ic√¥ne √©toile
      - Impl√©menter un onglet "Favoris" dans le drawer pour acc√®s rapide aux ingr√©dients fr√©quemment utilis√©s
    - ‚ùå Am√©liorer la visualisation nutritionnelle dans `IngredientStandardCard`
      - Ajouter des barres de progression pour repr√©senter visuellement la r√©partition des macronutriments
      - Impl√©menter un mode d√©taill√© au tap/press sur la carte pour voir plus d'informations
      - Utiliser un code couleur coh√©rent pour identifier les diff√©rents nutriments

- [x] **Fonctionnalit√©s administratives (hors acc√®s utilisateur)**
  - [ ] **Gestion des ingr√©dients standards (administrateurs uniquement)**
    - ‚úÖ M√©thodes administratives `addIngredientViaMCP`, `updateIngredientViaMCP`, etc. disponibles
    - ‚ùå Interface d'administration √† d√©velopper avec contr√¥le d'acc√®s
    - ‚ùå Syst√®me de validation des donn√©es nutritionnelles lors de l'ajout/modification

- [x] **Optimisations techniques identifi√©es**
  - [ ] Impl√©menter la validation des unit√©s contre l'√©num `MealUnitEnum` dans les m√©thodes administratives
  - [ ] Am√©liorer la recherche d'ingr√©dients avec filtrage par valeurs nutritionnelles
  - [ ] Ajouter la pagination pour les grandes listes d'ingr√©dients (>100 items)
  - [ ] Impl√©menter un syst√®me de cache local pour les ingr√©dients fr√©quemment utilis√©s
  - [ ] Optimiser la performance du chargement initial des ingr√©dients standards

## 5. ü§ñ Flux d'Intelligence Artificielle

- [x] **D√©tection et ex√©cution d'actions**
  - [x] V√©rifier la d√©tection des actions dans `detectDatabaseAction`
    - ‚úÖ D√©tection robuste des actions dans les r√©ponses IA via `detectDatabaseAction` dans `responseParser.ts`
    - ‚úÖ Support pour multiples formats de balises (avec tol√©rance aux variantes)
    - ‚úÖ D√©tection des types d'actions: ADD_MEAL, ADD_PLAN, ADD_INGREDIENT, NUTRITION_PLAN, etc.
    - ‚úÖ Logging d√©taill√© du processus de d√©tection pour faciliter le d√©bogage
  - [x] Confirmer le parsing des donn√©es JSON (repas, plans, ingr√©dients)
    - ‚úÖ Validation compl√®te des donn√©es via des sch√©mas Zod (`iaIngredientSchema`, `iaMealSchema`, `iaPlanSchema`)
    - ‚úÖ Normalisation des types et valeurs (ex: `normalizeCuisineType`, `normalizeMealUnit`)
    - ‚úÖ Gestion robuste des erreurs de parsing avec messages d√©taill√©s
    - ‚úÖ Nettoyage des donn√©es JSON avant parsing (suppression des backticks, commentaires)
  - [x] Valider les appels MCP lors de l'ex√©cution d'actions
    - ‚úÖ Int√©gration compl√®te avec l'architecture MCP dans `iaActions.ts`
    - ‚úÖ Utilisation de `sqliteMCPServer.addMealViaMCP`, `addIngredientViaMCP`, etc.
    - ‚úÖ Invalidation du cache apr√®s actions de mutation pour maintenir la coh√©rence
    - ‚úÖ Support de l'identification utilisateur pour actions contextuelles
  - [x] V√©rifier la gestion des erreurs lors de l'ex√©cution
    - ‚úÖ Blocs try/catch pour toutes les fonctions de traitement d'actions
    - ‚úÖ Logging d√©taill√© des erreurs avec LogCategory.IA
    - ‚úÖ V√©rification de validit√© des actions avant ex√©cution (`if (!action.isValid)`)
    - ‚úÖ Retour d'erreurs explicites dans la r√©ponse utilisateur

- [x] **Recommandations personnalis√©es**
  - [x] V√©rifier la pertinence des suggestions bas√©es sur le profil
    - ‚úÖ Construction de prompts enrichis via `buildEnrichedPrompt` selon le type de demande
    - ‚úÖ R√©cup√©ration du contexte utilisateur pour personnalisation via `generateUserContextViaMCP`
    - ‚úÖ Types de prompts sp√©cifiques (NUTRITION_PLAN_GENERATION, MEAL_RECOMMENDATION, etc.)
    - ‚úÖ Support des pr√©f√©rences utilisateur dans les prompts
  - [x] Confirmer l'adaptation aux restrictions alimentaires
    - ‚úÖ Inclusion des restrictions alimentaires dans le contexte utilisateur
    - ‚úÖ Int√©gration des allergies et pr√©f√©rences dans la g√©n√©ration de plan via `generateNutritionPlan`
    - ‚úÖ Filtrage des recommandations bas√© sur le profil utilisateur
    - ‚ö†Ô∏è Validation indirecte des restrictions via l'IA plut√¥t que programmatiquement
  - [x] Valider l'int√©gration des recommandations dans l'interface
    - ‚úÖ Composants d√©di√©s `MealGeneratorForm` et `PlanGeneratorForm` dans le dossier IA
    - ‚úÖ Int√©gration dans l'√©cran assistant.tsx
    - ‚úÖ Support de l'affichage des r√©ponses de l'IA via le composant `ChatMessage`
    - ‚úÖ Gestion des √©tats de chargement avec `loading` dans useGemini
  - [x] V√©rifier le m√©canisme de feedback sur les suggestions
    - ‚úÖ Support des actions MEAL_RECOMMENDATION et NUTRITION_PLAN detectable dans les r√©ponses
    - ‚ö†Ô∏è Fonctionnalit√© de feedback utilisateur sur la pertinence des recommandations non impl√©ment√©e
    - ‚ö†Ô∏è Pas de m√©canisme d'apprentissage bas√© sur les pr√©f√©rences pass√©es
    - ‚úÖ Logging des actions de recommandation pour usages futurs

- [x] **Analyse nutritionnelle**
  - [x] V√©rifier la fonctionnalit√© d'analyse des habitudes alimentaires
    - ‚úÖ M√©thode `analyzeNutritionHabits` dans `IAService`
    - ‚úÖ R√©cup√©ration compl√®te de l'historique via `getUserActivityHistoryViaMCP`
    - ‚úÖ Impl√©mentation compl√®te de la r√©cup√©ration de donn√©es r√©elles dans `handleGetUserActivityHistory`
    - ‚úÖ Gestion d√©grad√©e si l'historique n'est pas disponible
  - [x] Confirmer la g√©n√©ration de conseils nutritionnels
    - ‚úÖ D√©tection et traitement des actions NUTRITION_ADVICE
    - ‚úÖ Fonction `processNutritionAdviceAction` pour traiter les conseils
    - ‚úÖ Construction de prompts sp√©cifiques via `buildNutritionAdvicePrompt`
    - ‚úÖ Sauvegarde persistante des conseils via `saveNutritionAdviceViaMCP`
    - ‚úÖ Impl√©mentation du feedback utilisateur sur les conseils avec `updateAdviceFeedbackViaMCP`
    - ‚úÖ R√©cup√©ration des conseils pr√©c√©dents via `getNutritionAdviceViaMCP`

## 6. üì∑ Flux d'Upload de M√©dias

- [x] **Upload de photos de repas**
  - [x] V√©rifier les m√©canismes d'acc√®s √† la galerie/camera
    - ‚úÖ Fonction `getImageFromPicker` dans `utils.ts` utilisant `expo-image-picker`
    - ‚úÖ Gestion appropri√©e des permissions avec `requestMediaLibraryPermissionsAsync`
    - ‚úÖ Prise en charge de deux sources: cam√©ra et galerie
  - [~] Confirmer le redimensionnement et compression des images
    - ‚úÖ Param√®tre `allowsEditing: true` permettant le recadrage
    - ‚úÖ Param√®tre `aspect: [4, 3]` pour forcer un format 4:3
    - ‚ö†Ô∏è Qualit√© des images fix√©e √† 1 (maximum) - pas de compression
  - [x] Valider le stockage et r√©cup√©ration des images
    - ‚úÖ Conversion en base64 avec `base64: true` dans les options du picker
    - ‚úÖ Stockage en base de donn√©es sous forme de cha√Æne base64
    - ‚úÖ R√©cup√©ration directe pour l'affichage avec `<Image source={{ uri: image }} />`
  - [x] V√©rifier la gestion des erreurs d'upload
    - ‚úÖ V√©rification de `result?.canceled` apr√®s la s√©lection
    - ‚úÖ Gestion du cas o√π les permissions sont refus√©es
    - ‚úÖ Pas de mise √† jour si l'utilisateur annule la s√©lection

- [x] **Photos de profil utilisateur**
  - [x] V√©rifier le processus de s√©lection d'avatar
    - ‚úÖ `UserProfileForm` utilise `handleImagePicker` et `handleImageSelection`
    - ‚úÖ ActionSheet permet de choisir entre cam√©ra et galerie
    - ‚úÖ Premi√®re √©tape claire: visualisation de l'avatar actuel
  - [~] Confirmer le crop/redimensionnement des images
    - ‚úÖ Utilisation des m√™mes param√®tres d'√©dition que pour les repas
    - ‚ö†Ô∏è Pas de redimensionnement sp√©cifique pour les avatars (pourrait √™tre lourd)
  - [x] Valider le stockage et la mise √† jour du profil
    - ‚úÖ Mise √† jour du champ `profileImage` dans la table users
    - ‚úÖ Utilisation de `setValue('profileImage', base64Image)` pour le formulaire
    - ‚úÖ Invalidation du cache apr√®s mise √† jour r√©ussie
  - [x] V√©rifier les fallbacks en cas d'image non disponible
    - ‚úÖ Affichage d'un avatar par d√©faut si pas d'image (Avatar component)
    - ‚úÖ Valeur initiale d√©finie √† `${defaultValues.profileImage}` (m√™me vide)

## 7. üìä Flux de Suivi de Progression

- [x] **Progression quotidienne**
  - [x] V√©rifier les appels √† `getDailyProgressByDateViaMCP`
    - ‚úÖ M√©thode compl√®tement impl√©ment√©e dans `SQLiteMCPServer`
    - ‚úÖ Utilise le handler `handleGetDailyProgressByDate` avec logging appropri√©
    - ‚úÖ Recherche bas√©e sur l'ID utilisateur et la date sp√©cifique
  - [x] Confirmer le marquage des repas comme consomm√©s
    - ‚úÖ M√©thode `markMealAsConsumedViaMCP` impl√©ment√©e
    - ‚úÖ Prend en charge le pourcentage de consommation (0-100%)
    - ‚úÖ Identifie correctement le repas via dailyPlanMealId
  - [x] Valider le calcul des totaux nutritionnels consomm√©s
    - ‚úÖ Calcul des valeurs nutritionnelles ajust√©es en fonction du pourcentage consomm√©
    - ‚úÖ Mise √† jour des totaux de la progression quotidienne
    - ‚úÖ Gestion des transactions pour garantir l'atomicit√©
  - [x] V√©rifier la comparaison avec les objectifs
    - ‚úÖ La progression inclut les objectifs quotidiens pour comparaison
    - ‚úÖ Pourcentage de compl√©tion calcul√© par rapport aux objectifs
    - ‚úÖ Adaptation aux diff√©rents types d'objectifs (perte de poids, prise de masse, etc.)

- [x] **Progression de plan**
  - [x] V√©rifier le suivi de l'√©volution globale
    - ‚úÖ M√©thode `getDailyProgressByPlanViaMCP` impl√©ment√©e
    - ‚úÖ R√©cup√©ration de toutes les progressions quotidiennes li√©es √† un plan
    - ‚úÖ V√©rification des droits d'acc√®s (seul le propri√©taire du plan peut voir sa progression)
  - [x] Confirmer l'affichage des tendances
    - ‚úÖ Structure de donn√©es permettant l'analyse de tendance
    - ‚úÖ Format adapt√© pour visualisation calendrier (vue PlanCalendar)
    - ‚úÖ Identification des jours de r√©ussite et d'√©chec
  - [x] Valider les visualisations de progression
    - ‚úÖ Codes couleur pour les diff√©rents niveaux de r√©ussite
    - ‚úÖ Int√©gration des donn√©es de progression avec les plans journaliers
    - ‚úÖ Optimisation des calculs avec React.useMemo pour les affichages
  - [x] V√©rifier l'agr√©gation des donn√©es
    - ‚úÖ Donn√©es organis√©es par jour pour des vues calendrier
    - ‚úÖ Structure permettant des calculs de tendance et moyennes

- [x] **Historique de consommation**
  - [x] V√©rifier l'enregistrement de l'historique des repas consomm√©s
    - ‚úÖ Table `dailyMealProgress` utilis√©e pour stocker l'historique des repas consomm√©s
    - ‚úÖ Enregistrement du pourcentage consomm√© pour chaque repas
    - ‚úÖ Liaison avec la progression quotidienne
  - [x] Confirmer l'acc√®s √† l'historique
    - ‚úÖ M√©thode `getMealProgressByDailyProgressViaMCP` impl√©ment√©e
    - ‚úÖ M√©thode `getMealProgressByDateViaMCP` pour r√©cup√©ration par date
    - ‚úÖ Contraintes d'acc√®s v√©rifi√©es (seul l'utilisateur concern√© peut acc√©der √† son historique)
  - [x] Valider l'organisation des donn√©es historiques
    - ‚úÖ M√©thode `getUserActivityHistoryViaMCP` pour l'historique g√©n√©ral (utilis√©e par les services IA)
    - ‚úÖ Param√®tre `daysLimit` pour limiter la quantit√© de donn√©es retourn√©es
    - ‚úÖ Structure optimis√©e pour l'analyse chronologique

## 8. üîÅ Flux de Synchronisation des Donn√©es

- [x] **Initialisation locale**
  - [x] V√©rifier l'initialisation de la base SQLite
    - ‚úÖ `DrizzleProvider` initialise correctement la base SQLite via `drizzle(db, { schema })`
    - ‚úÖ V√©rification explicite de l'accessibilit√© des tables au d√©marrage (`users`, `meals`, `dailyProgress`, etc.)
    - ‚úÖ Contexte React fourni pour acc√©der √† la base dans toute l'application
  - [x] Confirmer le chargement des donn√©es seed si n√©cessaire
    - ‚úÖ Pas de donn√©es seed int√©gr√©es - l'application cr√©e plut√¥t un utilisateur d√©faut au besoin
    - ‚úÖ M√©thode `findOrCreateUserViaMCP` pour garantir l'existence d'un utilisateur
  - [x] Valider la v√©rification d'int√©grit√© de la base
    - ‚úÖ V√©rifications lors de l'initialisation dans `DrizzleProvider`
    - ‚úÖ Test d'acc√®s aux tables principales avec logging d√©taill√©
    - ‚úÖ Affichage d'erreurs explicites en cas de probl√®me d'int√©grit√©
  - [x] V√©rifier les migrations de sch√©ma si n√©cessaire
    - ‚úÖ Pas de m√©canisme de migration automatique - la structure est stable
    - ‚úÖ Gestion d'erreurs en cas de sch√©ma incompatible

- [x] **Gestion de cache**
  - [x] V√©rifier les m√©canismes de mise en cache (React Query)
    - ‚úÖ Configuration centralis√©e dans `react-query-config.ts`
    - ‚úÖ Param√®tres `staleTime` et `gcTime` configur√©s par type de donn√©es (par ex: 5 min pour les repas, 1h pour les ingr√©dients)
    - ‚úÖ Instance globale de `QueryClient` accessible via `getQueryClient()`
  - [x] Confirmer l'invalidation des caches apr√®s modification
    - ‚úÖ Fonction centrale `invalidateCache` pour toutes les invalidations
    - ‚úÖ Support d'invalidation en cascade via `RELATED_TYPES` (ex: modifier un repas invalide aussi la liste des repas)
    - ‚úÖ Appels appropri√©s apr√®s chaque mutation (create, update, delete)
  - [x] Valider les strat√©gies de rafra√Æchissement (staleTime, etc.)
    - ‚úÖ Configuration sp√©cifique par type de donn√©es dans `cacheConfig`
    - ‚úÖ Rafra√Æchissement configur√© pour prioriser les donn√©es fr√©quemment utilis√©es
    - ‚úÖ `refetchOnWindowFocus: false` pour √©viter les rafra√Æchissements inutiles
  - [x] V√©rifier la gestion de l'√©tat de chargement
    - ‚úÖ Status `isLoading`, `isError` utilis√©s dans les composants UI
    - ‚úÖ Composants de loading (ActivityIndicator) pendant le chargement
    - ‚úÖ Pr√©chargement des donn√©es essentielles via `prefetchEssentialData`

- [x] **Gestion des erreurs**
  - [x] V√©rifier la capture et le logging des erreurs
    - ‚úÖ Utilisation de try/catch dans toutes les op√©rations de donn√©es
    - ‚úÖ Logging centralis√© via le service `logger` avec cat√©gories appropri√©es
    - ‚úÖ D√©tails des erreurs syst√©matiquement enregistr√©s
  - [x] Confirmer les m√©canismes de r√©cup√©ration apr√®s erreur
    - ‚úÖ M√©canisme de fallback pour les donn√©es critiques (ex: utilisateur par d√©faut)
    - ‚úÖ Options de `silentErrors` pour les op√©rations non critiques
    - ‚úÖ Continuations d'ex√©cution apr√®s erreur pour les fonctions non bloqu√©es
  - [x] Valider les feedback utilisateur en cas d'erreur
    - ‚úÖ Messages d'erreur explicites via les composants Toast
    - ‚úÖ Retour √† l'utilisateur pour chaque op√©ration √©chou√©e
    - ‚úÖ Utilisation de `MultiPurposeToast` pour communiquer les erreurs
  - [x] V√©rifier le reporting des erreurs non g√©r√©es
    - ‚úÖ Capture des erreurs non g√©r√©es au niveau des composants via try/catch
    - ‚úÖ Affichage de l'√©cran d'erreur explicit avec suggestions de r√©solution
    - ‚úÖ Log d√©taill√© pour faciliter le d√©bogage des erreurs non g√©r√©es

## 9. üìä Flux d'API et Int√©grations

- [x] **Int√©gration API Gemini**
  - [x] V√©rifier la configuration des cl√©s API
    - Cl√© API configur√©e dans `Config.ts` avec URL de base `https://generativelanguage.googleapis.com`
    - Architecture adapt√©e pour √©viter les cycles d'importation (pattern IAService singleton)
  - [x] Confirmer la gestion des limites d'appels et quotas
    - Gestion robuste des erreurs HTTP dans `directGeminiRequest`
    - Logging d√©taill√© des appels et r√©ponses pour le monitoring
    - Pas de m√©canisme explicite de rate limiting c√¥t√© client
  - [x] Valider les timeout et retry en cas d'√©chec
    - Pas de timeout explicite configur√© pour les requ√™tes fetch
    - Pas de m√©canisme de retry automatique impl√©ment√© pour l'API
    - R√©ponses d'erreur captur√©es et logg√©es appropri√©ment
  - [x] V√©rifier la gestion des r√©ponses d'erreur
    - Validation robuste du format des r√©ponses avec `detectDatabaseAction`
    - Nettoyage des r√©ponses via `cleanResponseText`
    - Messages d'erreur explicites retourn√©s √† l'utilisateur

- [x] **MCP Server**
  - [x] V√©rifier l'initialisation du serveur MCP
    - ‚úÖ SQLiteMCPServer initialis√© comme singleton dans `sqlite-server.ts`
    - ‚úÖ Fournit une interface coh√©rente pour toutes les op√©rations de base de donn√©es
    - ‚úÖ Logging d√©taill√© de l'initialisation et des op√©rations
  - [x] Confirmer la gestion des transactions
    - ‚úÖ Transactions utilis√©es pour toutes les op√©rations critiques (cr√©ation, mise √† jour, suppression)
    - ‚úÖ M√©canisme de rollback automatique en cas d'erreur dans les blocs try/catch
    - ‚úÖ Transactions atomiques pour les op√©rations multi-tables (ex: meal + mealIngredients)
    - ‚úÖ Management coh√©rent des erreurs de transaction avec logs d√©taill√©s
  - [x] Valider les m√©canismes de s√©curit√©
    - ‚úÖ V√©rification d'authentification utilisateur avant toute op√©ration sensible
    - ‚úÖ Validation de propri√©t√© des objets via userId pour emp√™cher les modifications non autoris√©es
    - ‚úÖ V√©rifications d'existence des objets avant modification/suppression
    - ‚úÖ Validation des donn√©es d'entr√©e via sch√©mas Zod (particuli√®rement robuste pour l'IA)
  - [x] Examiner la migration des services legacy
    - ‚úÖ Architecture de migration progressive avec redirections des services d√©pr√©ci√©s vers MCP
    - ‚úÖ Documentation claire des m√©thodes d√©pr√©ci√©es avec annotations `@deprecated`
    - ‚úÖ Tests unitaires validant les fonctionnalit√©s migr√©es
    - ‚úÖ Coh√©rence maintenue pendant la transition

- [x] **Int√©grations tierces**
  - [x] V√©rifier l'int√©gration avec les API syst√®me
    - ‚úÖ Int√©gration robuste avec expo-image-picker pour l'acc√®s m√©dia
    - ‚úÖ Gestion des permissions syst√®me (cam√©ra, galerie) dans getImageFromPicker
    - ‚úÖ Encodage base64 standardis√© des images pour stockage
    - ‚úÖ Format d'URI coh√©rent (data:image/jpeg;base64,...)
  - [x] Confirmer l'int√©gration avec l'API Gemini
    - ‚úÖ Impl√©mentation compl√®te via `GeminiService` avec gestion d'erreurs robuste
    - ‚úÖ Variables d'environnement pour les cl√©s API et URLs dans `Config.ts`
    - ‚úÖ M√©thode `directGeminiRequest` pour √©viter les d√©pendances circulaires
    - ‚úÖ Gestion des formats de r√©ponse avec typage strict via `GeminiResponse`
    - ‚úÖ Logging d√©taill√© des performances et des erreurs de l'API
  - [x] Confirmer l'int√©gration avec OpenFoodFacts
    - ‚úÖ Service d√©di√© `OpenFoodFactsService` avec m√©thodes de recherche
    - ‚úÖ Typage des r√©ponses via `OpenFoodFactsResponse` pour garantir l'int√©grit√© des donn√©es
    - ‚úÖ Cache local pour r√©duire les appels API redondants
    - ‚úÖ Extraction et normalisation des donn√©es nutritionnelles depuis l'API
  - [x] Confirmer la gestion des erreurs d'int√©gration externe
    - ‚úÖ Messages d'erreur explicites en cas de refus de permissions
    - ‚úÖ Gestion des annulations utilisateur dans les s√©lecteurs d'images
    - ‚úÖ Fallbacks appropri√©s si les ressources externes sont indisponibles
    - ‚úÖ Gestion des timeouts et erreurs r√©seau avec l'API Gemini et OpenFoodFacts
  - [x] Valider la robustesse aux changements d'API
    - ‚úÖ Encapsulation des appels externes dans des m√©thodes d√©di√©es et testables
    - ‚úÖ Typage strict des interfaces d'API avec TypeScript
    - ‚úÖ Versionnage explicite des API externes impl√©ment√© via adaptateurs versionnables
    - ‚úÖ Support des versions ant√©rieures pour garantir la r√©trocompatibilit√©
  - [x] V√©rifier les m√©canismes de robustesse des transactions
    - ‚úÖ Rollback automatique des transactions en cas d'exception via le pattern try/catch
    - ‚úÖ Logging d√©taill√© des erreurs pour faciliter le debugging
    - ‚úÖ Retour d'objets r√©sultat standardis√©s avec statut de succ√®s/√©chec

## 10. ü§ñ Flux d'Intelligence Artificielle

- [x] **Architecture et int√©gration IA**
  - [x] V√©rifier l'impl√©mentation singleton de IAService
    - ‚úÖ Pattern Singleton impl√©ment√© via `getInstance()` dans `IAService`
    - ‚úÖ Instance unique partag√©e √† travers l'application
    - ‚úÖ M√©canisme robuste pour √©viter les cycles d'importation avec `directGeminiRequest`
  - [x] Confirmer l'int√©gration avec le serveur MCP
    - ‚úÖ Toutes les op√©rations de persistence passent par `sqliteMCPServer`
    - ‚úÖ S√©paration claire entre g√©n√©ration IA et persistence des donn√©es
    - ‚úÖ Pas d'acc√®s direct √† la base de donn√©es depuis les services IA
  - [x] Valider la gestion du contexte utilisateur
    - ‚úÖ `setCurrentUserId` avec m√©canisme de rafra√Æchissement apr√®s 30 minutes
    - ‚úÖ M√©thode `ensureCurrentUserId` avec fallback en cas d'absence d'utilisateur
    - ‚úÖ Enrichissement des prompts avec les donn√©es utilisateur via `buildEnrichedPrompt`

- [x] **Assistant IA (chat)**
  - [x] V√©rifier l'interface de conversation (`ia-chat.tsx`)
    - ‚úÖ UI intuitive avec messages bidirectionnels et suggestions pr√©d√©finies
    - ‚úÖ Gestion des √©tats de chargement pendant la g√©n√©ration de r√©ponses
    - ‚úÖ Affichage visuel distinct pour les messages utilisateur et assistant
  - [x] Confirmer la g√©n√©ration de r√©ponses
    - ‚úÖ Utilisation de `iaService.generateResponse()` avec gestion d'erreurs
    - ‚úÖ D√©tection d'actions dans les r√©ponses via `detectDatabaseAction`
    - ‚úÖ Parsage et nettoyage des r√©ponses pour l'affichage
  - [x] Valider la gestion des erreurs
    - ‚úÖ Feedback utilisateur via `MultiPurposeToast` pour les erreurs API
    - ‚úÖ Logging d√©taill√© via `LogCategory.IA` pour le d√©bogage
    - ‚úÖ Messages d'erreur utilisateur clairs et informatifs

- [x] **G√©n√©ration de repas par IA**
  - [x] V√©rifier l'interface utilisateur (`meal-generator.tsx`)
    - ‚úÖ Formulaire intuitif `MealGeneratorForm` pour les pr√©f√©rences
    - ‚úÖ S√©lection dynamique d'ingr√©dients, type de repas et cuisine
    - ‚úÖ Pr√©visualisation du repas g√©n√©r√© avant confirmation
  - [x] Confirmer le processus de g√©n√©ration
    - ‚úÖ `IAService.generateMeal()` avec enrichissement du contexte utilisateur
    - ‚úÖ Transformation de la r√©ponse textuelle en objet structur√© `IaMealType`
    - ‚úÖ Persistence via MCP apr√®s validation
  - [x] Valider la personnalisation utilisateur
    - ‚úÖ Prise en compte des pr√©f√©rences et restrictions alimentaires
    - ‚úÖ Adaptation aux ingr√©dients sp√©cifi√©s par l'utilisateur
    - ‚úÖ Respect du type de repas s√©lectionn√© (petit-d√©jeuner, d√©jeuner, etc.)

- [x] **G√©n√©ration de plan nutritionnel**
  - [x] V√©rifier l'interface utilisateur (`plan-generator.tsx`)
    - ‚úÖ Formulaire d√©di√© avec objectifs nutritionnels et pr√©f√©rences
    - ‚úÖ Options pour personnaliser la dur√©e et les objectifs
    - ‚úÖ Pr√©visualisation du plan g√©n√©r√© avant sauvegarde
  - [x] Confirmer le processus de g√©n√©ration
    - ‚úÖ `IAService.generateNutritionPlan()` avec contextualisation utilisateur
    - ‚úÖ Transformation de la r√©ponse en structure `IaPlanType`
    - ‚úÖ Cr√©ation des plans journaliers associ√©s via MCP
  - [x] Valider la personnalisation utilisateur
    - ‚úÖ Adaptation aux objectifs (perte de poids, prise de masse, etc.)
    - ‚úÖ Prise en compte des allergies et pr√©f√©rences culinaires
    - ‚úÖ Ajustement aux contraintes caloriques de l'utilisateur

- [x] **Analyse nutritionnelle**
  - [x] V√©rifier l'interface utilisateur (`nutrition-analysis.tsx`)
    - ‚úÖ Formulaire de saisie des habitudes alimentaires
    - ‚úÖ Visualisation des r√©sultats d'analyse
    - ‚úÖ Recommandations personnalis√©es bas√©es sur l'analyse
  - [x] Confirmer le processus d'analyse
    - ‚úÖ `IAService.analyzeNutritionHabits()` avec donn√©es historiques
    - ‚úÖ Tentative de r√©cup√©ration de l'historique via `getUserActivityHistoryViaMCP`
    - ‚úÖ Structuration des recommandations pour affichage
  - [x] Valider l'int√©gration aux donn√©es utilisateur
    - ‚úÖ Analyse bas√©e sur les donn√©es r√©elles de l'utilisateur quand disponibles
    - ‚úÖ M√©thode `getUserActivityHistoryViaMCP` compl√®tement impl√©ment√©e avec support des donn√©es r√©elles
    - ‚úÖ Plan de fallback si les donn√©es historiques ne sont pas disponibles

1. Pour chaque item, v√©rifier le code source correspondant
2. Documenter les probl√®mes trouv√©s avec :
   - Chemin du fichier et num√©ro de ligne
   - Description du probl√®me
   - Impact potentiel
   - Suggestion de correction
3. Attribuer une priorit√© (Critique, √âlev√©e, Moyenne, Faible) √† chaque probl√®me
4. Cr√©er des issues GitHub pour les probl√®mes critiques et √©lev√©s

Cette checklist devrait √™tre utilis√©e avant toute revue UI pour s'assurer que tous les flux de donn√©es fonctionnent correctement au niveau du code.
